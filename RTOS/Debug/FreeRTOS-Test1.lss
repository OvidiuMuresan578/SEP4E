
FreeRTOS-Test1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  00002406  0000249a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002406  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005e8  0080012e  0080012e  000024c8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000024c8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000024f8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000488  00000000  00000000  00002538  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005930  00000000  00000000  000029c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016ca  00000000  00000000  000082f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000030c8  00000000  00000000  000099ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f20  00000000  00000000  0000ca84  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c42  00000000  00000000  0000d9a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000057c9  00000000  00000000  0000f5e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000558  00000000  00000000  00014daf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 b0 06 	jmp	0xd60	; 0xd60 <__vector_13>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 fd 03 	jmp	0x7fa	; 0x7fa <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 a6 07 	jmp	0xf4c	; 0xf4c <__vector_20>
      54:	0c 94 e4 07 	jmp	0xfc8	; 0xfc8 <__vector_21>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 2c 08 	jmp	0x1058	; 0x1058 <__vector_28>
      74:	0c 94 6a 08 	jmp	0x10d4	; 0x10d4 <__vector_29>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	e6 e0       	ldi	r30, 0x06	; 6
      90:	f4 e2       	ldi	r31, 0x24	; 36
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ae 32       	cpi	r26, 0x2E	; 46
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	27 e0       	ldi	r18, 0x07	; 7
      a0:	ae e2       	ldi	r26, 0x2E	; 46
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	a6 31       	cpi	r26, 0x16	; 22
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 af 03 	call	0x75e	; 0x75e <main>
      b2:	0c 94 01 12 	jmp	0x2402	; 0x2402 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <connection>:
static int ballDirectionY ; //can be 1 or -1 going down or up

//-----------------------------------------

void connection(void *pvParameters)
{
      ba:	cf 93       	push	r28
      bc:	df 93       	push	r29
      be:	1f 92       	push	r1
      c0:	cd b7       	in	r28, 0x3d	; 61
      c2:	de b7       	in	r29, 0x3e	; 62
	// The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task not to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 2 );
      c4:	62 e0       	ldi	r22, 0x02	; 2
      c6:	70 e0       	ldi	r23, 0x00	; 0
      c8:	80 e0       	ldi	r24, 0x00	; 0
      ca:	90 e0       	ldi	r25, 0x00	; 0
      cc:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <vTaskSetApplicationTaskTag>
	BaseType_t result = 0;
	uint8_t byte;
	
	while(1)
	{
		result = xQueueReceive(_x_com_received_chars_queue, &byte, 1000L); //this is what it receives
      d0:	20 e0       	ldi	r18, 0x00	; 0
      d2:	48 ee       	ldi	r20, 0xE8	; 232
      d4:	53 e0       	ldi	r21, 0x03	; 3
      d6:	be 01       	movw	r22, r28
      d8:	6f 5f       	subi	r22, 0xFF	; 255
      da:	7f 4f       	sbci	r23, 0xFF	; 255
      dc:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <_x_com_received_chars_queue>
      e0:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <_x_com_received_chars_queue+0x1>
      e4:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <xQueueGenericReceive>
		
		if (result) { //if there is a result
      e8:	88 23       	and	r24, r24
      ea:	31 f0       	breq	.+12     	; 0xf8 <connection+0x3e>
			com_send_bytes(&byte, 1); //send byte back
      ec:	61 e0       	ldi	r22, 0x01	; 1
      ee:	ce 01       	movw	r24, r28
      f0:	01 96       	adiw	r24, 0x01	; 1
      f2:	0e 94 26 04 	call	0x84c	; 0x84c <com_send_bytes>
      f6:	ec cf       	rjmp	.-40     	; 0xd0 <connection+0x16>
			}else {//if there is no result
			com_send_bytes((uint8_t*)"TO", 2);//send back to 2 ?
      f8:	62 e0       	ldi	r22, 0x02	; 2
      fa:	8e e0       	ldi	r24, 0x0E	; 14
      fc:	91 e0       	ldi	r25, 0x01	; 1
      fe:	0e 94 26 04 	call	0x84c	; 0x84c <com_send_bytes>
     102:	e6 cf       	rjmp	.-52     	; 0xd0 <connection+0x16>

00000104 <move_player_and_ball>:
void move_player_and_ball(void *pvParameters){
	// The parameters are not used
	( void ) pvParameters;
	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
     104:	61 e0       	ldi	r22, 0x01	; 1
     106:	70 e0       	ldi	r23, 0x00	; 0
     108:	80 e0       	ldi	r24, 0x00	; 0
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <vTaskSetApplicationTaskTag>
	#endif
	//Game logic for P1 and ball from here
		while(1){
				player1Y = 1;
     110:	88 24       	eor	r8, r8
     112:	83 94       	inc	r8
     114:	91 2c       	mov	r9, r1
			    player2Y = 1;
			    end = 0;
			    ballX = 3;
     116:	03 e0       	ldi	r16, 0x03	; 3
     118:	10 e0       	ldi	r17, 0x00	; 0
			    ballY = 4;
     11a:	68 94       	set
     11c:	aa 24       	eor	r10, r10
     11e:	a2 f8       	bld	r10, 2
     120:	b1 2c       	mov	r11, r1
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
	#endif
	//Game logic for P1 and ball from here
		while(1){
				player1Y = 1;
     122:	90 92 40 01 	sts	0x0140, r9	; 0x800140 <player1Y+0x1>
     126:	80 92 3f 01 	sts	0x013F, r8	; 0x80013f <player1Y>
			    player2Y = 1;
     12a:	90 92 3e 01 	sts	0x013E, r9	; 0x80013e <player2Y+0x1>
     12e:	80 92 3d 01 	sts	0x013D, r8	; 0x80013d <player2Y>
			    end = 0;
     132:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <end+0x1>
     136:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <end>
			    ballX = 3;
     13a:	10 93 36 01 	sts	0x0136, r17	; 0x800136 <ballX+0x1>
     13e:	00 93 35 01 	sts	0x0135, r16	; 0x800135 <ballX>
			    ballY = 4;
     142:	b0 92 34 01 	sts	0x0134, r11	; 0x800134 <ballY+0x1>
     146:	a0 92 33 01 	sts	0x0133, r10	; 0x800133 <ballY>
			    ballDirectionX = 1; //can be 1 or -1 going right or left
     14a:	90 92 32 01 	sts	0x0132, r9	; 0x800132 <ballDirectionX+0x1>
     14e:	80 92 31 01 	sts	0x0131, r8	; 0x800131 <ballDirectionX>
			    ballDirectionY = 1; //can be 1 or -1 going down or up
     152:	90 92 30 01 	sts	0x0130, r9	; 0x800130 <ballDirectionY+0x1>
     156:	80 92 2f 01 	sts	0x012F, r8	; 0x80012f <ballDirectionY>
		 //boolean for ending the game
		//From here on the game starts. If a game ends, it will just start again.
		while (end == 0) {
			if( xSemaphoreTake( xMutex, 500) ){
     15a:	20 e0       	ldi	r18, 0x00	; 0
     15c:	44 ef       	ldi	r20, 0xF4	; 244
     15e:	51 e0       	ldi	r21, 0x01	; 1
     160:	60 e0       	ldi	r22, 0x00	; 0
     162:	70 e0       	ldi	r23, 0x00	; 0
     164:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <xMutex>
     168:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <xMutex+0x1>
     16c:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <xQueueGenericReceive>
     170:	88 23       	and	r24, r24
     172:	09 f4       	brne	.+2      	; 0x176 <move_player_and_ball+0x72>
     174:	d7 c0       	rjmp	.+430    	; 0x324 <move_player_and_ball+0x220>
			
			int PinCValue = PINC & 0b11000011 ; // Masking PINC
     176:	86 b1       	in	r24, 0x06	; 6
     178:	83 7c       	andi	r24, 0xC3	; 195
     17a:	90 e0       	ldi	r25, 0x00	; 0
			//Moving the character
				
			if(PinCValue==up)
     17c:	20 91 06 01 	lds	r18, 0x0106	; 0x800106 <up>
     180:	30 91 07 01 	lds	r19, 0x0107	; 0x800107 <up+0x1>
     184:	82 17       	cp	r24, r18
     186:	93 07       	cpc	r25, r19
     188:	c1 f4       	brne	.+48     	; 0x1ba <move_player_and_ball+0xb6>
				if (player1Y != 1){
     18a:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <player1Y>
     18e:	30 91 40 01 	lds	r19, 0x0140	; 0x800140 <player1Y+0x1>
     192:	21 30       	cpi	r18, 0x01	; 1
     194:	31 05       	cpc	r19, r1
     196:	09 f4       	brne	.+2      	; 0x19a <move_player_and_ball+0x96>
     198:	d1 c0       	rjmp	.+418    	; 0x33c <move_player_and_ball+0x238>
						player1Y = player1Y - 1;
     19a:	21 50       	subi	r18, 0x01	; 1
     19c:	31 09       	sbc	r19, r1
     19e:	30 93 40 01 	sts	0x0140, r19	; 0x800140 <player1Y+0x1>
     1a2:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <player1Y>
						player2Y = player2Y - 1;} //temporary until PC connectivity is implemented
     1a6:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <player2Y>
     1aa:	30 91 3e 01 	lds	r19, 0x013E	; 0x80013e <player2Y+0x1>
     1ae:	21 50       	subi	r18, 0x01	; 1
     1b0:	31 09       	sbc	r19, r1
     1b2:	30 93 3e 01 	sts	0x013E, r19	; 0x80013e <player2Y+0x1>
     1b6:	20 93 3d 01 	sts	0x013D, r18	; 0x80013d <player2Y>
					
			if(PinCValue==down)
     1ba:	20 91 08 01 	lds	r18, 0x0108	; 0x800108 <down>
     1be:	30 91 09 01 	lds	r19, 0x0109	; 0x800109 <down+0x1>
     1c2:	82 17       	cp	r24, r18
     1c4:	93 07       	cpc	r25, r19
     1c6:	b1 f4       	brne	.+44     	; 0x1f4 <move_player_and_ball+0xf0>
				if (player1Y != 6){
     1c8:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <player1Y>
     1cc:	30 91 40 01 	lds	r19, 0x0140	; 0x800140 <player1Y+0x1>
     1d0:	26 30       	cpi	r18, 0x06	; 6
     1d2:	31 05       	cpc	r19, r1
     1d4:	79 f0       	breq	.+30     	; 0x1f4 <move_player_and_ball+0xf0>
						player1Y = player1Y + 1;
     1d6:	2f 5f       	subi	r18, 0xFF	; 255
     1d8:	3f 4f       	sbci	r19, 0xFF	; 255
     1da:	30 93 40 01 	sts	0x0140, r19	; 0x800140 <player1Y+0x1>
     1de:	20 93 3f 01 	sts	0x013F, r18	; 0x80013f <player1Y>
						player2Y = player2Y + 1;} //temporary until PC connectivity is implemented
     1e2:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <player2Y>
     1e6:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <player2Y+0x1>
     1ea:	01 96       	adiw	r24, 0x01	; 1
     1ec:	90 93 3e 01 	sts	0x013E, r25	; 0x80013e <player2Y+0x1>
     1f0:	80 93 3d 01 	sts	0x013D, r24	; 0x80013d <player2Y>

			//Move ball

				if(maze[ballY+ballDirectionY][ballX+ballDirectionX]==1) //if ball is going and on the next position would enter the same pixel as a wall, it will change direction
     1f4:	40 91 33 01 	lds	r20, 0x0133	; 0x800133 <ballY>
     1f8:	50 91 34 01 	lds	r21, 0x0134	; 0x800134 <ballY+0x1>
     1fc:	a0 91 2f 01 	lds	r26, 0x012F	; 0x80012f <ballDirectionY>
     200:	b0 91 30 01 	lds	r27, 0x0130	; 0x800130 <ballDirectionY+0x1>
     204:	9a 01       	movw	r18, r20
     206:	2a 0f       	add	r18, r26
     208:	3b 1f       	adc	r19, r27
     20a:	60 91 35 01 	lds	r22, 0x0135	; 0x800135 <ballX>
     20e:	70 91 36 01 	lds	r23, 0x0136	; 0x800136 <ballX+0x1>
     212:	e0 90 31 01 	lds	r14, 0x0131	; 0x800131 <ballDirectionX>
     216:	f0 90 32 01 	lds	r15, 0x0132	; 0x800132 <ballDirectionX+0x1>
     21a:	fb 01       	movw	r30, r22
     21c:	ee 0d       	add	r30, r14
     21e:	ff 1d       	adc	r31, r15
     220:	69 01       	movw	r12, r18
     222:	cc 0c       	add	r12, r12
     224:	dd 1c       	adc	r13, r13
     226:	c6 01       	movw	r24, r12
     228:	88 0f       	add	r24, r24
     22a:	99 1f       	adc	r25, r25
     22c:	88 0f       	add	r24, r24
     22e:	99 1f       	adc	r25, r25
     230:	88 0f       	add	r24, r24
     232:	99 1f       	adc	r25, r25
     234:	8c 19       	sub	r24, r12
     236:	9d 09       	sbc	r25, r13
     238:	8e 0f       	add	r24, r30
     23a:	9f 1f       	adc	r25, r31
     23c:	88 0f       	add	r24, r24
     23e:	99 1f       	adc	r25, r25
     240:	86 50       	subi	r24, 0x06	; 6
     242:	9a 4f       	sbci	r25, 0xFA	; 250
     244:	ec 01       	movw	r28, r24
     246:	88 81       	ld	r24, Y
     248:	99 81       	ldd	r25, Y+1	; 0x01
     24a:	81 30       	cpi	r24, 0x01	; 1
     24c:	91 05       	cpc	r25, r1
     24e:	41 f4       	brne	.+16     	; 0x260 <move_player_and_ball+0x15c>
					ballDirectionY=ballDirectionY*(-1);
     250:	b1 95       	neg	r27
     252:	a1 95       	neg	r26
     254:	b1 09       	sbc	r27, r1
     256:	b0 93 30 01 	sts	0x0130, r27	; 0x800130 <ballDirectionY+0x1>
     25a:	a0 93 2f 01 	sts	0x012F, r26	; 0x80012f <ballDirectionY>
     25e:	43 c0       	rjmp	.+134    	; 0x2e6 <move_player_and_ball+0x1e2>
					
				else if(maze[ballX+ballDirectionX][ballY+ballDirectionY]==2)
     260:	ee 0f       	add	r30, r30
     262:	ff 1f       	adc	r31, r31
     264:	6f 01       	movw	r12, r30
     266:	cc 0c       	add	r12, r12
     268:	dd 1c       	adc	r13, r13
     26a:	cc 0c       	add	r12, r12
     26c:	dd 1c       	adc	r13, r13
     26e:	cc 0c       	add	r12, r12
     270:	dd 1c       	adc	r13, r13
     272:	e6 01       	movw	r28, r12
     274:	ce 1b       	sub	r28, r30
     276:	df 0b       	sbc	r29, r31
     278:	fe 01       	movw	r30, r28
     27a:	e2 0f       	add	r30, r18
     27c:	f3 1f       	adc	r31, r19
     27e:	ee 0f       	add	r30, r30
     280:	ff 1f       	adc	r31, r31
     282:	e6 50       	subi	r30, 0x06	; 6
     284:	fa 4f       	sbci	r31, 0xFA	; 250
     286:	20 81       	ld	r18, Z
     288:	31 81       	ldd	r19, Z+1	; 0x01
     28a:	22 30       	cpi	r18, 0x02	; 2
     28c:	31 05       	cpc	r19, r1
     28e:	d9 f4       	brne	.+54     	; 0x2c6 <move_player_and_ball+0x1c2>
				{							 //if ball is going and on the next position would enter game over position, one player wins the game
				if(ballDirectionX==1){
     290:	ea 94       	dec	r14
     292:	ef 28       	or	r14, r15
     294:	51 f4       	brne	.+20     	; 0x2aa <move_player_and_ball+0x1a6>
					score1++;}
     296:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <score1>
     29a:	90 91 3a 01 	lds	r25, 0x013A	; 0x80013a <score1+0x1>
     29e:	01 96       	adiw	r24, 0x01	; 1
     2a0:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <score1+0x1>
     2a4:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <score1>
     2a8:	09 c0       	rjmp	.+18     	; 0x2bc <move_player_and_ball+0x1b8>
				else{
					score2++;}
     2aa:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <score2>
     2ae:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <score2+0x1>
     2b2:	01 96       	adiw	r24, 0x01	; 1
     2b4:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <score2+0x1>
     2b8:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <score2>
					
				end = 1;
     2bc:	90 92 3c 01 	sts	0x013C, r9	; 0x80013c <end+0x1>
     2c0:	80 92 3b 01 	sts	0x013B, r8	; 0x80013b <end>
     2c4:	10 c0       	rjmp	.+32     	; 0x2e6 <move_player_and_ball+0x1e2>
				}
				
				else if(maze[ballY+ballDirectionY][ballX+ballDirectionX]==3) // if ball is going and on next position hits a player, it will change direction
     2c6:	03 97       	sbiw	r24, 0x03	; 3
     2c8:	71 f4       	brne	.+28     	; 0x2e6 <move_player_and_ball+0x1e2>
					{
						ballDirectionY=ballDirectionY*(-1);
     2ca:	b1 95       	neg	r27
     2cc:	a1 95       	neg	r26
     2ce:	b1 09       	sbc	r27, r1
     2d0:	b0 93 30 01 	sts	0x0130, r27	; 0x800130 <ballDirectionY+0x1>
     2d4:	a0 93 2f 01 	sts	0x012F, r26	; 0x80012f <ballDirectionY>
						ballDirectionX=ballDirectionX*(-1);
     2d8:	f1 94       	neg	r15
     2da:	e1 94       	neg	r14
     2dc:	f1 08       	sbc	r15, r1
     2de:	f0 92 32 01 	sts	0x0132, r15	; 0x800132 <ballDirectionX+0x1>
     2e2:	e0 92 31 01 	sts	0x0131, r14	; 0x800131 <ballDirectionX>
					}
					
				ballX=ballX+ballDirectionX;
     2e6:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <ballDirectionX>
     2ea:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <ballDirectionX+0x1>
     2ee:	68 0f       	add	r22, r24
     2f0:	79 1f       	adc	r23, r25
     2f2:	70 93 36 01 	sts	0x0136, r23	; 0x800136 <ballX+0x1>
     2f6:	60 93 35 01 	sts	0x0135, r22	; 0x800135 <ballX>
				ballY=ballY+ballDirectionY;
     2fa:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <ballDirectionY>
     2fe:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <ballDirectionY+0x1>
     302:	48 0f       	add	r20, r24
     304:	59 1f       	adc	r21, r25
     306:	50 93 34 01 	sts	0x0134, r21	; 0x800134 <ballY+0x1>
     30a:	40 93 33 01 	sts	0x0133, r20	; 0x800133 <ballY>
				
				xSemaphoreGive(xMutex);
     30e:	20 e0       	ldi	r18, 0x00	; 0
     310:	40 e0       	ldi	r20, 0x00	; 0
     312:	50 e0       	ldi	r21, 0x00	; 0
     314:	60 e0       	ldi	r22, 0x00	; 0
     316:	70 e0       	ldi	r23, 0x00	; 0
     318:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <xMutex>
     31c:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <xMutex+0x1>
     320:	0e 94 e6 09 	call	0x13cc	; 0x13cc <xQueueGenericSend>
				}
			vTaskDelay(100);  // Task delay
     324:	84 e6       	ldi	r24, 0x64	; 100
     326:	90 e0       	ldi	r25, 0x00	; 0
     328:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskDelay>
			    ballY = 4;
			    ballDirectionX = 1; //can be 1 or -1 going right or left
			    ballDirectionY = 1; //can be 1 or -1 going down or up
		 //boolean for ending the game
		//From here on the game starts. If a game ends, it will just start again.
		while (end == 0) {
     32c:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <end>
     330:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <end+0x1>
     334:	89 2b       	or	r24, r25
     336:	09 f4       	brne	.+2      	; 0x33a <move_player_and_ball+0x236>
     338:	10 cf       	rjmp	.-480    	; 0x15a <move_player_and_ball+0x56>
     33a:	f3 ce       	rjmp	.-538    	; 0x122 <move_player_and_ball+0x1e>
			if(PinCValue==up)
				if (player1Y != 1){
						player1Y = player1Y - 1;
						player2Y = player2Y - 1;} //temporary until PC connectivity is implemented
					
			if(PinCValue==down)
     33c:	40 91 08 01 	lds	r20, 0x0108	; 0x800108 <down>
     340:	50 91 09 01 	lds	r21, 0x0109	; 0x800109 <down+0x1>
     344:	84 17       	cp	r24, r20
     346:	95 07       	cpc	r25, r21
     348:	09 f0       	breq	.+2      	; 0x34c <move_player_and_ball+0x248>
     34a:	54 cf       	rjmp	.-344    	; 0x1f4 <move_player_and_ball+0xf0>
     34c:	44 cf       	rjmp	.-376    	; 0x1d6 <move_player_and_ball+0xd2>

0000034e <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     34e:	5a 9a       	sbi	0x0b, 2	; 11
     350:	08 95       	ret

00000352 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     352:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     354:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     356:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     358:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     35a:	5a 98       	cbi	0x0b, 2	; 11
     35c:	08 95       	ret

0000035e <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     35e:	80 95       	com	r24
     360:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     362:	85 b1       	in	r24, 0x05	; 5
     364:	83 60       	ori	r24, 0x03	; 3
     366:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     368:	85 b1       	in	r24, 0x05	; 5
     36a:	93 70       	andi	r25, 0x03	; 3
     36c:	90 95       	com	r25
     36e:	89 23       	and	r24, r25
     370:	85 b9       	out	0x05, r24	; 5
     372:	08 95       	ret

00000374 <handle_display>:
}

//-----------------------------------------
void handle_display(void)
{
     374:	cf 93       	push	r28
	static uint8_t col = 0;
	
	if (col == 0)
     376:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <__data_end>
     37a:	c1 11       	cpse	r28, r1
     37c:	0e c0       	rjmp	.+28     	; 0x39a <handle_display+0x26>
	{
		prepare_shiftregister();
     37e:	0e 94 a7 01 	call	0x34e	; 0x34e <prepare_shiftregister>
	}
	
	load_col_value(frame_buf[col]);
     382:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <frame_buf>
     386:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <frame_buf+0x1>
     38a:	0e 94 af 01 	call	0x35e	; 0x35e <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     38e:	0e 94 a9 01 	call	0x352	; 0x352 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     392:	81 e0       	ldi	r24, 0x01	; 1
     394:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end>
     398:	14 c0       	rjmp	.+40     	; 0x3c2 <handle_display+0x4e>
	if (col == 0)
	{
		prepare_shiftregister();
	}
	
	load_col_value(frame_buf[col]);
     39a:	ec 2f       	mov	r30, r28
     39c:	f0 e0       	ldi	r31, 0x00	; 0
     39e:	ee 0f       	add	r30, r30
     3a0:	ff 1f       	adc	r31, r31
     3a2:	ef 5b       	subi	r30, 0xBF	; 191
     3a4:	fe 4f       	sbci	r31, 0xFE	; 254
     3a6:	80 81       	ld	r24, Z
     3a8:	91 81       	ldd	r25, Z+1	; 0x01
     3aa:	0e 94 af 01 	call	0x35e	; 0x35e <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     3ae:	0e 94 a9 01 	call	0x352	; 0x352 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     3b2:	cf 5f       	subi	r28, 0xFF	; 255
	if (col > 13)
     3b4:	ce 30       	cpi	r28, 0x0E	; 14
     3b6:	18 f4       	brcc	.+6      	; 0x3be <handle_display+0x4a>
	load_col_value(frame_buf[col]);
	
	clock_shift_register_and_prepare_for_next_col();
	
	// count column up - prepare for next
	col++;
     3b8:	c0 93 2e 01 	sts	0x012E, r28	; 0x80012e <__data_end>
     3bc:	02 c0       	rjmp	.+4      	; 0x3c2 <handle_display+0x4e>
	if (col > 13)
	{
		col = 0;
     3be:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <__data_end>
	}
}
     3c2:	cf 91       	pop	r28
     3c4:	08 95       	ret

000003c6 <innitMaze>:
//----------------------------------------- FUNCTIONS
//Game 


void innitMaze()
{
     3c6:	cf 93       	push	r28
     3c8:	df 93       	push	r29
     3ca:	4a ef       	ldi	r20, 0xFA	; 250
     3cc:	55 e0       	ldi	r21, 0x05	; 5
	for (int i = 0; i < 10; i++)
     3ce:	20 e0       	ldi	r18, 0x00	; 0
     3d0:	30 e0       	ldi	r19, 0x00	; 0
	for (int j = 0; j < 14; j++) {
		maze[i][j] = 0;
		if(j==0 || j==13)
			maze[i][j] = 2; //left and right 'walls' that the ball needs to reach to end the game
     3d2:	c2 e0       	ldi	r28, 0x02	; 2
     3d4:	d0 e0       	ldi	r29, 0x00	; 0
		if (i == 0 || i ==9)
			maze[i][j] = 1; //top and bottom borders
     3d6:	61 e0       	ldi	r22, 0x01	; 1
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	1f c0       	rjmp	.+62     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
     3dc:	df 01       	movw	r26, r30

void innitMaze()
{
	for (int i = 0; i < 10; i++)
	for (int j = 0; j < 14; j++) {
		maze[i][j] = 0;
     3de:	11 82       	std	Z+1, r1	; 0x01
     3e0:	10 82       	st	Z, r1
		if(j==0 || j==13)
     3e2:	00 97       	sbiw	r24, 0x00	; 0
     3e4:	19 f0       	breq	.+6      	; 0x3ec <innitMaze+0x26>
     3e6:	8d 30       	cpi	r24, 0x0D	; 13
     3e8:	91 05       	cpc	r25, r1
     3ea:	19 f4       	brne	.+6      	; 0x3f2 <innitMaze+0x2c>
			maze[i][j] = 2; //left and right 'walls' that the ball needs to reach to end the game
     3ec:	11 96       	adiw	r26, 0x01	; 1
     3ee:	dc 93       	st	X, r29
     3f0:	ce 93       	st	-X, r28
		if (i == 0 || i ==9)
     3f2:	21 15       	cp	r18, r1
     3f4:	31 05       	cpc	r19, r1
     3f6:	19 f0       	breq	.+6      	; 0x3fe <innitMaze+0x38>
     3f8:	29 30       	cpi	r18, 0x09	; 9
     3fa:	31 05       	cpc	r19, r1
     3fc:	11 f4       	brne	.+4      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
			maze[i][j] = 1; //top and bottom borders
     3fe:	6d 93       	st	X+, r22
     400:	7c 93       	st	X, r23


void innitMaze()
{
	for (int i = 0; i < 10; i++)
	for (int j = 0; j < 14; j++) {
     402:	01 96       	adiw	r24, 0x01	; 1
     404:	32 96       	adiw	r30, 0x02	; 2
     406:	8e 30       	cpi	r24, 0x0E	; 14
     408:	91 05       	cpc	r25, r1
     40a:	41 f7       	brne	.-48     	; 0x3dc <innitMaze+0x16>
//Game 


void innitMaze()
{
	for (int i = 0; i < 10; i++)
     40c:	2f 5f       	subi	r18, 0xFF	; 255
     40e:	3f 4f       	sbci	r19, 0xFF	; 255
     410:	44 5e       	subi	r20, 0xE4	; 228
     412:	5f 4f       	sbci	r21, 0xFF	; 255
     414:	2a 30       	cpi	r18, 0x0A	; 10
     416:	31 05       	cpc	r19, r1
     418:	21 f0       	breq	.+8      	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
//----------------------------------------- FUNCTIONS
//Game 


void innitMaze()
{
     41a:	fa 01       	movw	r30, r20
     41c:	80 e0       	ldi	r24, 0x00	; 0
     41e:	90 e0       	ldi	r25, 0x00	; 0
     420:	dd cf       	rjmp	.-70     	; 0x3dc <innitMaze+0x16>
		if(j==0 || j==13)
			maze[i][j] = 2; //left and right 'walls' that the ball needs to reach to end the game
		if (i == 0 || i ==9)
			maze[i][j] = 1; //top and bottom borders
	}
}
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	08 95       	ret

00000428 <startup_task>:
	// The parameters are not used
	( void ) pvParameters;

	#if (configUSE_APPLICATION_TASK_TAG == 1)
	// Set task no to be used for tracing with R2R-Network
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1 );
     428:	61 e0       	ldi	r22, 0x01	; 1
     42a:	70 e0       	ldi	r23, 0x00	; 0
     42c:	80 e0       	ldi	r24, 0x00	; 0
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <vTaskSetApplicationTaskTag>
	#endif
	
	_x_com_received_chars_queue = xQueueCreate( _COM_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
     434:	40 e0       	ldi	r20, 0x00	; 0
     436:	61 e0       	ldi	r22, 0x01	; 1
     438:	8e e1       	ldi	r24, 0x1E	; 30
     43a:	0e 94 b5 09 	call	0x136a	; 0x136a <xQueueGenericCreate>
     43e:	90 93 60 01 	sts	0x0160, r25	; 0x800160 <_x_com_received_chars_queue+0x1>
     442:	80 93 5f 01 	sts	0x015F, r24	; 0x80015f <_x_com_received_chars_queue>
	init_com(_x_com_received_chars_queue);
     446:	0e 94 e6 03 	call	0x7cc	; 0x7cc <init_com>
	xMutex = xSemaphoreCreateMutex();
     44a:	81 e0       	ldi	r24, 0x01	; 1
     44c:	0e 94 87 0a 	call	0x150e	; 0x150e <xQueueCreateMutex>
     450:	90 93 5e 01 	sts	0x015E, r25	; 0x80015e <xMutex+0x1>
     454:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <xMutex>
	innitMaze();
     458:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <innitMaze>
	// Initialization of tasks etc. can be done here
	BaseType_t t1 = xTaskCreate(connection, (const char *)"Connection", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY+1, NULL);
     45c:	e1 2c       	mov	r14, r1
     45e:	f1 2c       	mov	r15, r1
     460:	01 e0       	ldi	r16, 0x01	; 1
     462:	20 e0       	ldi	r18, 0x00	; 0
     464:	30 e0       	ldi	r19, 0x00	; 0
     466:	45 e5       	ldi	r20, 0x55	; 85
     468:	50 e0       	ldi	r21, 0x00	; 0
     46a:	61 e1       	ldi	r22, 0x11	; 17
     46c:	71 e0       	ldi	r23, 0x01	; 1
     46e:	8d e5       	ldi	r24, 0x5D	; 93
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xTaskCreate>
	BaseType_t t2 = xTaskCreate(move_player_and_ball, (const char *)"Move", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY+3, NULL);
     476:	03 e0       	ldi	r16, 0x03	; 3
     478:	20 e0       	ldi	r18, 0x00	; 0
     47a:	30 e0       	ldi	r19, 0x00	; 0
     47c:	45 e5       	ldi	r20, 0x55	; 85
     47e:	50 e0       	ldi	r21, 0x00	; 0
     480:	6c e1       	ldi	r22, 0x1C	; 28
     482:	71 e0       	ldi	r23, 0x01	; 1
     484:	82 e8       	ldi	r24, 0x82	; 130
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xTaskCreate>
	BaseType_t t3 = xTaskCreate(refresh_display, (const char *)"Move", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY+2, NULL);
     48c:	02 e0       	ldi	r16, 0x02	; 2
     48e:	20 e0       	ldi	r18, 0x00	; 0
     490:	30 e0       	ldi	r19, 0x00	; 0
     492:	45 e5       	ldi	r20, 0x55	; 85
     494:	50 e0       	ldi	r21, 0x00	; 0
     496:	6c e1       	ldi	r22, 0x1C	; 28
     498:	71 e0       	ldi	r23, 0x01	; 1
     49a:	8f e8       	ldi	r24, 0x8F	; 143
     49c:	93 e0       	ldi	r25, 0x03	; 3
     49e:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xTaskCreate>
	// Lets send a start message to the console
	//com_send_bytes((uint8_t *)"Then we Start!\n", 15);
	
	while(1)
	{
		vTaskDelay( 1000 );
     4a2:	88 ee       	ldi	r24, 0xE8	; 232
     4a4:	93 e0       	ldi	r25, 0x03	; 3
     4a6:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskDelay>
     4aa:	fb cf       	rjmp	.-10     	; 0x4a2 <startup_task+0x7a>

000004ac <pow>:
	}
}

int pow( int base, int exponent)

{   // Does not work for negative exponents. (But that would be leaving the range of int)
     4ac:	0f 93       	push	r16
     4ae:	1f 93       	push	r17
     4b0:	cf 93       	push	r28
     4b2:	df 93       	push	r29
	if (exponent == 0) return 1;  // base case;
     4b4:	61 15       	cp	r22, r1
     4b6:	71 05       	cpc	r23, r1
     4b8:	29 f1       	breq	.+74     	; 0x504 <pow+0x58>
	int temp = pow(base, exponent/2);
     4ba:	9b 01       	movw	r18, r22
     4bc:	77 23       	and	r23, r23
     4be:	14 f4       	brge	.+4      	; 0x4c4 <pow+0x18>
     4c0:	2f 5f       	subi	r18, 0xFF	; 255
     4c2:	3f 4f       	sbci	r19, 0xFF	; 255
     4c4:	eb 01       	movw	r28, r22
     4c6:	8c 01       	movw	r16, r24
     4c8:	b9 01       	movw	r22, r18
     4ca:	75 95       	asr	r23
     4cc:	67 95       	ror	r22
     4ce:	0e 94 56 02 	call	0x4ac	; 0x4ac <pow>
     4d2:	9c 01       	movw	r18, r24
	if (exponent % 2 == 0)
     4d4:	c0 fd       	sbrc	r28, 0
     4d6:	07 c0       	rjmp	.+14     	; 0x4e6 <pow+0x3a>
	return temp * temp;
     4d8:	22 9f       	mul	r18, r18
     4da:	c0 01       	movw	r24, r0
     4dc:	23 9f       	mul	r18, r19
     4de:	90 0d       	add	r25, r0
     4e0:	90 0d       	add	r25, r0
     4e2:	11 24       	eor	r1, r1
     4e4:	11 c0       	rjmp	.+34     	; 0x508 <pow+0x5c>
	else
	return (base * temp * temp);
     4e6:	02 9f       	mul	r16, r18
     4e8:	a0 01       	movw	r20, r0
     4ea:	03 9f       	mul	r16, r19
     4ec:	50 0d       	add	r21, r0
     4ee:	12 9f       	mul	r17, r18
     4f0:	50 0d       	add	r21, r0
     4f2:	11 24       	eor	r1, r1
     4f4:	42 9f       	mul	r20, r18
     4f6:	c0 01       	movw	r24, r0
     4f8:	43 9f       	mul	r20, r19
     4fa:	90 0d       	add	r25, r0
     4fc:	52 9f       	mul	r21, r18
     4fe:	90 0d       	add	r25, r0
     500:	11 24       	eor	r1, r1
     502:	02 c0       	rjmp	.+4      	; 0x508 <pow+0x5c>
}

int pow( int base, int exponent)

{   // Does not work for negative exponents. (But that would be leaving the range of int)
	if (exponent == 0) return 1;  // base case;
     504:	81 e0       	ldi	r24, 0x01	; 1
     506:	90 e0       	ldi	r25, 0x00	; 0
	int temp = pow(base, exponent/2);
	if (exponent % 2 == 0)
	return temp * temp;
	else
	return (base * temp * temp);
}
     508:	df 91       	pop	r29
     50a:	cf 91       	pop	r28
     50c:	1f 91       	pop	r17
     50e:	0f 91       	pop	r16
     510:	08 95       	ret

00000512 <printMaze>:

void printMaze()  // PRINTS MAZE  /////////////////////////////////////////////////////////////////////////////////////
{
     512:	2f 92       	push	r2
     514:	3f 92       	push	r3
     516:	4f 92       	push	r4
     518:	5f 92       	push	r5
     51a:	6f 92       	push	r6
     51c:	7f 92       	push	r7
     51e:	8f 92       	push	r8
     520:	9f 92       	push	r9
     522:	af 92       	push	r10
     524:	bf 92       	push	r11
     526:	cf 92       	push	r12
     528:	df 92       	push	r13
     52a:	ef 92       	push	r14
     52c:	ff 92       	push	r15
     52e:	0f 93       	push	r16
     530:	1f 93       	push	r17
     532:	cf 93       	push	r28
     534:	df 93       	push	r29
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
     53a:	60 97       	sbiw	r28, 0x10	; 16
     53c:	0f b6       	in	r0, 0x3f	; 63
     53e:	f8 94       	cli
     540:	de bf       	out	0x3e, r29	; 62
     542:	0f be       	out	0x3f, r0	; 63
     544:	cd bf       	out	0x3d, r28	; 61
	for (int j = 0; j < 14; j++) {
		int dec = 0;
		int power = 0;
		for (int i = 0; i < 10; i++)
		{
			if (maze[i][j] == 1 || (j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i) || (j==ballX && ballY== i)) {
     546:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <player2Y>
     54a:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <player2Y+0x1>
     54e:	9e 83       	std	Y+6, r25	; 0x06
     550:	8d 83       	std	Y+5, r24	; 0x05
     552:	01 96       	adiw	r24, 0x01	; 1
     554:	9c 87       	std	Y+12, r25	; 0x0c
     556:	8b 87       	std	Y+11, r24	; 0x0b
     558:	ed 81       	ldd	r30, Y+5	; 0x05
     55a:	fe 81       	ldd	r31, Y+6	; 0x06
     55c:	32 96       	adiw	r30, 0x02	; 2
     55e:	fe 87       	std	Y+14, r31	; 0x0e
     560:	ed 87       	std	Y+13, r30	; 0x0d
     562:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <player1Y>
     566:	90 91 40 01 	lds	r25, 0x0140	; 0x800140 <player1Y+0x1>
     56a:	9c 83       	std	Y+4, r25	; 0x04
     56c:	8b 83       	std	Y+3, r24	; 0x03
     56e:	01 96       	adiw	r24, 0x01	; 1
     570:	98 87       	std	Y+8, r25	; 0x08
     572:	8f 83       	std	Y+7, r24	; 0x07
     574:	eb 81       	ldd	r30, Y+3	; 0x03
     576:	fc 81       	ldd	r31, Y+4	; 0x04
     578:	32 96       	adiw	r30, 0x02	; 2
     57a:	fa 87       	std	Y+10, r31	; 0x0a
     57c:	e9 87       	std	Y+9, r30	; 0x09
     57e:	80 90 35 01 	lds	r8, 0x0135	; 0x800135 <ballX>
     582:	90 90 36 01 	lds	r9, 0x0136	; 0x800136 <ballX+0x1>
     586:	60 90 33 01 	lds	r6, 0x0133	; 0x800133 <ballY>
     58a:	70 90 34 01 	lds	r7, 0x0134	; 0x800134 <ballY+0x1>
     58e:	0f 2e       	mov	r0, r31
     590:	f1 e4       	ldi	r31, 0x41	; 65
     592:	2f 2e       	mov	r2, r31
     594:	f1 e0       	ldi	r31, 0x01	; 1
     596:	3f 2e       	mov	r3, r31
     598:	f0 2d       	mov	r31, r0
     59a:	0f 2e       	mov	r0, r31
     59c:	fa ef       	ldi	r31, 0xFA	; 250
     59e:	4f 2e       	mov	r4, r31
     5a0:	f5 e0       	ldi	r31, 0x05	; 5
     5a2:	5f 2e       	mov	r5, r31
     5a4:	f0 2d       	mov	r31, r0
}

void printMaze()  // PRINTS MAZE  /////////////////////////////////////////////////////////////////////////////////////
{

	for (int j = 0; j < 14; j++) {
     5a6:	00 e0       	ldi	r16, 0x00	; 0
     5a8:	10 e0       	ldi	r17, 0x00	; 0
		{
			if (maze[i][j] == 1 || (j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i) || (j==ballX && ballY== i)) {
				dec += pow(2, power);
			}
			if(j==0 || j==13){
				maze[i][j]	=2;
     5aa:	f2 e0       	ldi	r31, 0x02	; 2
     5ac:	f9 83       	std	Y+1, r31	; 0x01
     5ae:	1a 82       	std	Y+2, r1	; 0x02
     5b0:	74 c0       	rjmp	.+232    	; 0x69a <printMaze+0x188>
     5b2:	ef 84       	ldd	r14, Y+15	; 0x0f
     5b4:	f8 88       	ldd	r15, Y+16	; 0x10
	for (int j = 0; j < 14; j++) {
		int dec = 0;
		int power = 0;
		for (int i = 0; i < 10; i++)
		{
			if (maze[i][j] == 1 || (j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i) || (j==ballX && ballY== i)) {
     5b6:	f7 01       	movw	r30, r14
     5b8:	80 81       	ld	r24, Z
     5ba:	91 81       	ldd	r25, Z+1	; 0x01
     5bc:	01 97       	sbiw	r24, 0x01	; 1
     5be:	61 f1       	breq	.+88     	; 0x618 <printMaze+0x106>
     5c0:	01 15       	cp	r16, r1
     5c2:	11 05       	cpc	r17, r1
     5c4:	89 f4       	brne	.+34     	; 0x5e8 <printMaze+0xd6>
     5c6:	8b 81       	ldd	r24, Y+3	; 0x03
     5c8:	9c 81       	ldd	r25, Y+4	; 0x04
     5ca:	8c 15       	cp	r24, r12
     5cc:	9d 05       	cpc	r25, r13
     5ce:	21 f1       	breq	.+72     	; 0x618 <printMaze+0x106>
     5d0:	ef 81       	ldd	r30, Y+7	; 0x07
     5d2:	f8 85       	ldd	r31, Y+8	; 0x08
     5d4:	ec 15       	cp	r30, r12
     5d6:	fd 05       	cpc	r31, r13
     5d8:	f9 f0       	breq	.+62     	; 0x618 <printMaze+0x106>
     5da:	89 85       	ldd	r24, Y+9	; 0x09
     5dc:	9a 85       	ldd	r25, Y+10	; 0x0a
     5de:	8c 15       	cp	r24, r12
     5e0:	9d 05       	cpc	r25, r13
     5e2:	09 f0       	breq	.+2      	; 0x5e6 <printMaze+0xd4>
     5e4:	7b c0       	rjmp	.+246    	; 0x6dc <printMaze+0x1ca>
     5e6:	18 c0       	rjmp	.+48     	; 0x618 <printMaze+0x106>
     5e8:	0d 30       	cpi	r16, 0x0D	; 13
     5ea:	11 05       	cpc	r17, r1
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <printMaze+0xde>
     5ee:	72 c0       	rjmp	.+228    	; 0x6d4 <printMaze+0x1c2>
     5f0:	ed 81       	ldd	r30, Y+5	; 0x05
     5f2:	fe 81       	ldd	r31, Y+6	; 0x06
     5f4:	ec 15       	cp	r30, r12
     5f6:	fd 05       	cpc	r31, r13
     5f8:	79 f0       	breq	.+30     	; 0x618 <printMaze+0x106>
     5fa:	8b 85       	ldd	r24, Y+11	; 0x0b
     5fc:	9c 85       	ldd	r25, Y+12	; 0x0c
     5fe:	8c 15       	cp	r24, r12
     600:	9d 05       	cpc	r25, r13
     602:	51 f0       	breq	.+20     	; 0x618 <printMaze+0x106>
     604:	ed 85       	ldd	r30, Y+13	; 0x0d
     606:	fe 85       	ldd	r31, Y+14	; 0x0e
     608:	ec 15       	cp	r30, r12
     60a:	fd 05       	cpc	r31, r13
     60c:	09 f0       	breq	.+2      	; 0x610 <printMaze+0xfe>
     60e:	6a c0       	rjmp	.+212    	; 0x6e4 <printMaze+0x1d2>
     610:	03 c0       	rjmp	.+6      	; 0x618 <printMaze+0x106>
     612:	6c 14       	cp	r6, r12
     614:	7d 04       	cpc	r7, r13
     616:	39 f4       	brne	.+14     	; 0x626 <printMaze+0x114>
				dec += pow(2, power);
     618:	b6 01       	movw	r22, r12
     61a:	89 81       	ldd	r24, Y+1	; 0x01
     61c:	9a 81       	ldd	r25, Y+2	; 0x02
     61e:	0e 94 56 02 	call	0x4ac	; 0x4ac <pow>
     622:	a8 0e       	add	r10, r24
     624:	b9 1e       	adc	r11, r25
			}
			if(j==0 || j==13){
     626:	01 15       	cp	r16, r1
     628:	11 05       	cpc	r17, r1
     62a:	f1 f1       	breq	.+124    	; 0x6a8 <printMaze+0x196>
     62c:	0d 30       	cpi	r16, 0x0D	; 13
     62e:	11 05       	cpc	r17, r1
     630:	d9 f4       	brne	.+54     	; 0x668 <printMaze+0x156>
     632:	45 c0       	rjmp	.+138    	; 0x6be <printMaze+0x1ac>
				maze[i][j]	=2;
				if((j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i)){
     634:	8f 81       	ldd	r24, Y+7	; 0x07
     636:	98 85       	ldd	r25, Y+8	; 0x08
     638:	8c 15       	cp	r24, r12
     63a:	9d 05       	cpc	r25, r13
     63c:	81 f0       	breq	.+32     	; 0x65e <printMaze+0x14c>
     63e:	e9 85       	ldd	r30, Y+9	; 0x09
     640:	fa 85       	ldd	r31, Y+10	; 0x0a
     642:	ec 15       	cp	r30, r12
     644:	fd 05       	cpc	r31, r13
     646:	81 f4       	brne	.+32     	; 0x668 <printMaze+0x156>
     648:	0a c0       	rjmp	.+20     	; 0x65e <printMaze+0x14c>
     64a:	8b 85       	ldd	r24, Y+11	; 0x0b
     64c:	9c 85       	ldd	r25, Y+12	; 0x0c
     64e:	8c 15       	cp	r24, r12
     650:	9d 05       	cpc	r25, r13
     652:	29 f0       	breq	.+10     	; 0x65e <printMaze+0x14c>
     654:	ed 85       	ldd	r30, Y+13	; 0x0d
     656:	fe 85       	ldd	r31, Y+14	; 0x0e
     658:	ec 15       	cp	r30, r12
     65a:	fd 05       	cpc	r31, r13
     65c:	29 f4       	brne	.+10     	; 0x668 <printMaze+0x156>
					maze[i][j]	=3;
     65e:	83 e0       	ldi	r24, 0x03	; 3
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	f7 01       	movw	r30, r14
     664:	91 83       	std	Z+1, r25	; 0x01
     666:	80 83       	st	Z, r24
{

	for (int j = 0; j < 14; j++) {
		int dec = 0;
		int power = 0;
		for (int i = 0; i < 10; i++)
     668:	9f ef       	ldi	r25, 0xFF	; 255
     66a:	c9 1a       	sub	r12, r25
     66c:	d9 0a       	sbc	r13, r25
     66e:	ef 85       	ldd	r30, Y+15	; 0x0f
     670:	f8 89       	ldd	r31, Y+16	; 0x10
     672:	7c 96       	adiw	r30, 0x1c	; 28
     674:	f8 8b       	std	Y+16, r31	; 0x10
     676:	ef 87       	std	Y+15, r30	; 0x0f
     678:	fa e0       	ldi	r31, 0x0A	; 10
     67a:	cf 16       	cp	r12, r31
     67c:	d1 04       	cpc	r13, r1
     67e:	09 f0       	breq	.+2      	; 0x682 <printMaze+0x170>
     680:	98 cf       	rjmp	.-208    	; 0x5b2 <printMaze+0xa0>
				}
			}
			
				power++;
		}
		frame_buf[j]=dec;
     682:	f1 01       	movw	r30, r2
     684:	a1 92       	st	Z+, r10
     686:	b1 92       	st	Z+, r11
     688:	1f 01       	movw	r2, r30
}

void printMaze()  // PRINTS MAZE  /////////////////////////////////////////////////////////////////////////////////////
{

	for (int j = 0; j < 14; j++) {
     68a:	0f 5f       	subi	r16, 0xFF	; 255
     68c:	1f 4f       	sbci	r17, 0xFF	; 255
     68e:	f2 e0       	ldi	r31, 0x02	; 2
     690:	4f 0e       	add	r4, r31
     692:	51 1c       	adc	r5, r1
     694:	0e 30       	cpi	r16, 0x0E	; 14
     696:	11 05       	cpc	r17, r1
     698:	49 f1       	breq	.+82     	; 0x6ec <printMaze+0x1da>
	else
	return (base * temp * temp);
}

void printMaze()  // PRINTS MAZE  /////////////////////////////////////////////////////////////////////////////////////
{
     69a:	58 8a       	std	Y+16, r5	; 0x10
     69c:	4f 86       	std	Y+15, r4	; 0x0f
     69e:	c1 2c       	mov	r12, r1
     6a0:	d1 2c       	mov	r13, r1
     6a2:	a1 2c       	mov	r10, r1
     6a4:	b1 2c       	mov	r11, r1
     6a6:	85 cf       	rjmp	.-246    	; 0x5b2 <printMaze+0xa0>
		{
			if (maze[i][j] == 1 || (j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i) || (j==ballX && ballY== i)) {
				dec += pow(2, power);
			}
			if(j==0 || j==13){
				maze[i][j]	=2;
     6a8:	82 e0       	ldi	r24, 0x02	; 2
     6aa:	f7 01       	movw	r30, r14
     6ac:	80 83       	st	Z, r24
     6ae:	11 82       	std	Z+1, r1	; 0x01
				if((j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i)){
     6b0:	eb 81       	ldd	r30, Y+3	; 0x03
     6b2:	fc 81       	ldd	r31, Y+4	; 0x04
     6b4:	ec 15       	cp	r30, r12
     6b6:	fd 05       	cpc	r31, r13
     6b8:	09 f0       	breq	.+2      	; 0x6bc <printMaze+0x1aa>
     6ba:	bc cf       	rjmp	.-136    	; 0x634 <printMaze+0x122>
     6bc:	d0 cf       	rjmp	.-96     	; 0x65e <printMaze+0x14c>
		{
			if (maze[i][j] == 1 || (j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i) || (j==ballX && ballY== i)) {
				dec += pow(2, power);
			}
			if(j==0 || j==13){
				maze[i][j]	=2;
     6be:	82 e0       	ldi	r24, 0x02	; 2
     6c0:	f7 01       	movw	r30, r14
     6c2:	80 83       	st	Z, r24
     6c4:	11 82       	std	Z+1, r1	; 0x01
				if((j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i)){
     6c6:	ed 81       	ldd	r30, Y+5	; 0x05
     6c8:	fe 81       	ldd	r31, Y+6	; 0x06
     6ca:	ec 15       	cp	r30, r12
     6cc:	fd 05       	cpc	r31, r13
     6ce:	09 f0       	breq	.+2      	; 0x6d2 <printMaze+0x1c0>
     6d0:	bc cf       	rjmp	.-136    	; 0x64a <printMaze+0x138>
     6d2:	c5 cf       	rjmp	.-118    	; 0x65e <printMaze+0x14c>
	for (int j = 0; j < 14; j++) {
		int dec = 0;
		int power = 0;
		for (int i = 0; i < 10; i++)
		{
			if (maze[i][j] == 1 || (j==0 && player1Y == i) || (j==0 && player1Y+1 == i) || (j==0 && player1Y+2 == i) || (j==13 && player2Y == i) || (j==13 && player2Y+1 == i) || (j==13 && player2Y+2 == i) || (j==ballX && ballY== i)) {
     6d4:	80 16       	cp	r8, r16
     6d6:	91 06       	cpc	r9, r17
     6d8:	39 f6       	brne	.-114    	; 0x668 <printMaze+0x156>
     6da:	9b cf       	rjmp	.-202    	; 0x612 <printMaze+0x100>
     6dc:	80 16       	cp	r8, r16
     6de:	91 06       	cpc	r9, r17
     6e0:	19 f7       	brne	.-58     	; 0x6a8 <printMaze+0x196>
     6e2:	97 cf       	rjmp	.-210    	; 0x612 <printMaze+0x100>
     6e4:	80 16       	cp	r8, r16
     6e6:	91 06       	cpc	r9, r17
     6e8:	51 f7       	brne	.-44     	; 0x6be <printMaze+0x1ac>
     6ea:	93 cf       	rjmp	.-218    	; 0x612 <printMaze+0x100>
			
				power++;
		}
		frame_buf[j]=dec;
	}
}
     6ec:	60 96       	adiw	r28, 0x10	; 16
     6ee:	0f b6       	in	r0, 0x3f	; 63
     6f0:	f8 94       	cli
     6f2:	de bf       	out	0x3e, r29	; 62
     6f4:	0f be       	out	0x3f, r0	; 63
     6f6:	cd bf       	out	0x3d, r28	; 61
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	1f 91       	pop	r17
     6fe:	0f 91       	pop	r16
     700:	ff 90       	pop	r15
     702:	ef 90       	pop	r14
     704:	df 90       	pop	r13
     706:	cf 90       	pop	r12
     708:	bf 90       	pop	r11
     70a:	af 90       	pop	r10
     70c:	9f 90       	pop	r9
     70e:	8f 90       	pop	r8
     710:	7f 90       	pop	r7
     712:	6f 90       	pop	r6
     714:	5f 90       	pop	r5
     716:	4f 90       	pop	r4
     718:	3f 90       	pop	r3
     71a:	2f 90       	pop	r2
     71c:	08 95       	ret

0000071e <refresh_display>:
	
//-----------------------------------------
void refresh_display(void *pvParameters)
{
	for(;;){
			if( xSemaphoreTake( xMutex, 2050) ){
     71e:	20 e0       	ldi	r18, 0x00	; 0
     720:	42 e0       	ldi	r20, 0x02	; 2
     722:	58 e0       	ldi	r21, 0x08	; 8
     724:	60 e0       	ldi	r22, 0x00	; 0
     726:	70 e0       	ldi	r23, 0x00	; 0
     728:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <xMutex>
     72c:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <xMutex+0x1>
     730:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <xQueueGenericReceive>
     734:	88 23       	and	r24, r24
     736:	99 f3       	breq	.-26     	; 0x71e <refresh_display>
			printMaze();
     738:	0e 94 89 02 	call	0x512	; 0x512 <printMaze>
			vTaskDelay(100);
     73c:	84 e6       	ldi	r24, 0x64	; 100
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskDelay>
			xSemaphoreGive( xMutex );
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	40 e0       	ldi	r20, 0x00	; 0
     748:	50 e0       	ldi	r21, 0x00	; 0
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	70 e0       	ldi	r23, 0x00	; 0
     74e:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <xMutex>
     752:	90 91 5e 01 	lds	r25, 0x015E	; 0x80015e <xMutex+0x1>
     756:	0e 94 e6 09 	call	0x13cc	; 0x13cc <xQueueGenericSend>
     75a:	e1 cf       	rjmp	.-62     	; 0x71e <refresh_display>

0000075c <vApplicationIdleHook>:
	}
}


void vApplicationIdleHook( void )
{
     75c:	08 95       	ret

0000075e <main>:
}

//-----------------------------------------
int main(void)
{
	init_board();
     75e:	0e 94 2f 04 	call	0x85e	; 0x85e <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     762:	5e 98       	cbi	0x0b, 6	; 11
	
	//creates tasks
	BaseType_t t1 = xTaskCreate(startup_task, (const char *)"Startup", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL); // This task starts the other tasks as well. I guess.
     764:	e1 2c       	mov	r14, r1
     766:	f1 2c       	mov	r15, r1
     768:	00 e0       	ldi	r16, 0x00	; 0
     76a:	20 e0       	ldi	r18, 0x00	; 0
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	45 e5       	ldi	r20, 0x55	; 85
     770:	50 e0       	ldi	r21, 0x00	; 0
     772:	61 e2       	ldi	r22, 0x21	; 33
     774:	71 e0       	ldi	r23, 0x01	; 1
     776:	84 e1       	ldi	r24, 0x14	; 20
     778:	92 e0       	ldi	r25, 0x02	; 2
     77a:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xTaskCreate>

	// Start the display handler timer
	init_display_timer(handle_display);
     77e:	8a eb       	ldi	r24, 0xBA	; 186
     780:	91 e0       	ldi	r25, 0x01	; 1
     782:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <init_display_timer>
	
	
	sei();
     786:	78 94       	sei
	//Start the scheduler
	vTaskStartScheduler();
     788:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <vTaskStartScheduler>
     78c:	ff cf       	rjmp	.-2      	; 0x78c <main+0x2e>

0000078e <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29
     792:	00 d0       	rcall	.+0      	; 0x794 <_com_call_back+0x6>
     794:	cd b7       	in	r28, 0x3d	; 61
     796:	de b7       	in	r29, 0x3e	; 62
     798:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     79a:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <_x_rx_com_queue>
     79e:	90 91 aa 01 	lds	r25, 0x01AA	; 0x8001aa <_x_rx_com_queue+0x1>
     7a2:	00 97       	sbiw	r24, 0x00	; 0
     7a4:	71 f0       	breq	.+28     	; 0x7c2 <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     7a6:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     7a8:	20 e0       	ldi	r18, 0x00	; 0
     7aa:	ae 01       	movw	r20, r28
     7ac:	4f 5f       	subi	r20, 0xFF	; 255
     7ae:	5f 4f       	sbci	r21, 0xFF	; 255
     7b0:	be 01       	movw	r22, r28
     7b2:	6e 5f       	subi	r22, 0xFE	; 254
     7b4:	7f 4f       	sbci	r23, 0xFF	; 255
     7b6:	0e 94 a1 0a 	call	0x1542	; 0x1542 <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     7ba:	89 81       	ldd	r24, Y+1	; 0x01
     7bc:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     7be:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
		}
	}
}
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	08 95       	ret

000007cc <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     7cc:	90 93 aa 01 	sts	0x01AA, r25	; 0x8001aa <_x_rx_com_queue+0x1>
     7d0:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <_x_rx_com_queue>
     7d4:	08 95       	ret

000007d6 <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     7d6:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <cb_ptr+0x1>
     7da:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     7de:	8a e0       	ldi	r24, 0x0A	; 10
     7e0:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     7e2:	84 b5       	in	r24, 0x24	; 36
     7e4:	82 60       	ori	r24, 0x02	; 2
     7e6:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     7e8:	ee e6       	ldi	r30, 0x6E	; 110
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	80 81       	ld	r24, Z
     7ee:	82 60       	ori	r24, 0x02	; 2
     7f0:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     7f2:	85 b5       	in	r24, 0x25	; 37
     7f4:	85 60       	ori	r24, 0x05	; 5
     7f6:	85 bd       	out	0x25, r24	; 37
     7f8:	08 95       	ret

000007fa <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     7fa:	1f 92       	push	r1
     7fc:	0f 92       	push	r0
     7fe:	0f b6       	in	r0, 0x3f	; 63
     800:	0f 92       	push	r0
     802:	11 24       	eor	r1, r1
     804:	2f 93       	push	r18
     806:	3f 93       	push	r19
     808:	4f 93       	push	r20
     80a:	5f 93       	push	r21
     80c:	6f 93       	push	r22
     80e:	7f 93       	push	r23
     810:	8f 93       	push	r24
     812:	9f 93       	push	r25
     814:	af 93       	push	r26
     816:	bf 93       	push	r27
     818:	ef 93       	push	r30
     81a:	ff 93       	push	r31
	if (cb_ptr)
     81c:	e0 91 a7 01 	lds	r30, 0x01A7	; 0x8001a7 <cb_ptr>
     820:	f0 91 a8 01 	lds	r31, 0x01A8	; 0x8001a8 <cb_ptr+0x1>
     824:	30 97       	sbiw	r30, 0x00	; 0
     826:	09 f0       	breq	.+2      	; 0x82a <__vector_16+0x30>
	{
		cb_ptr();
     828:	09 95       	icall
	}
}
     82a:	ff 91       	pop	r31
     82c:	ef 91       	pop	r30
     82e:	bf 91       	pop	r27
     830:	af 91       	pop	r26
     832:	9f 91       	pop	r25
     834:	8f 91       	pop	r24
     836:	7f 91       	pop	r23
     838:	6f 91       	pop	r22
     83a:	5f 91       	pop	r21
     83c:	4f 91       	pop	r20
     83e:	3f 91       	pop	r19
     840:	2f 91       	pop	r18
     842:	0f 90       	pop	r0
     844:	0f be       	out	0x3f, r0	; 63
     846:	0f 90       	pop	r0
     848:	1f 90       	pop	r1
     84a:	18 95       	reti

0000084c <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     84c:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     84e:	bc 01       	movw	r22, r24
     850:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <_com_serial_instance>
     854:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <_com_serial_instance+0x1>
     858:	0e 94 63 07 	call	0xec6	; 0xec6 <serial_send_bytes>
     85c:	08 95       	ret

0000085e <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     85e:	8f 92       	push	r8
     860:	9f 92       	push	r9
     862:	af 92       	push	r10
     864:	bf 92       	push	r11
     866:	cf 92       	push	r12
     868:	df 92       	push	r13
     86a:	ef 92       	push	r14
     86c:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     86e:	84 e8       	ldi	r24, 0x84	; 132
     870:	91 e0       	ldi	r25, 0x01	; 1
     872:	0e 94 88 04 	call	0x910	; 0x910 <buffer_init>
	buffer_init(&_com_tx_buffer);
     876:	81 e6       	ldi	r24, 0x61	; 97
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	0e 94 88 04 	call	0x910	; 0x910 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     87e:	0f 2e       	mov	r0, r31
     880:	f7 ec       	ldi	r31, 0xC7	; 199
     882:	8f 2e       	mov	r8, r31
     884:	f3 e0       	ldi	r31, 0x03	; 3
     886:	9f 2e       	mov	r9, r31
     888:	f0 2d       	mov	r31, r0
     88a:	0f 2e       	mov	r0, r31
     88c:	f1 e6       	ldi	r31, 0x61	; 97
     88e:	af 2e       	mov	r10, r31
     890:	f1 e0       	ldi	r31, 0x01	; 1
     892:	bf 2e       	mov	r11, r31
     894:	f0 2d       	mov	r31, r0
     896:	0f 2e       	mov	r0, r31
     898:	f4 e8       	ldi	r31, 0x84	; 132
     89a:	cf 2e       	mov	r12, r31
     89c:	f1 e0       	ldi	r31, 0x01	; 1
     89e:	df 2e       	mov	r13, r31
     8a0:	f0 2d       	mov	r31, r0
     8a2:	e1 2c       	mov	r14, r1
     8a4:	00 e0       	ldi	r16, 0x00	; 0
     8a6:	23 e0       	ldi	r18, 0x03	; 3
     8a8:	40 e0       	ldi	r20, 0x00	; 0
     8aa:	52 ec       	ldi	r21, 0xC2	; 194
     8ac:	61 e0       	ldi	r22, 0x01	; 1
     8ae:	70 e0       	ldi	r23, 0x00	; 0
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <serial_new_instance>
     8b6:	90 93 ac 01 	sts	0x01AC, r25	; 0x8001ac <_com_serial_instance+0x1>
     8ba:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     8be:	88 b1       	in	r24, 0x08	; 8
     8c0:	83 6c       	ori	r24, 0xC3	; 195
     8c2:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     8c4:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     8c6:	8a b1       	in	r24, 0x0a	; 10
     8c8:	84 67       	ori	r24, 0x74	; 116
     8ca:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     8cc:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     8ce:	81 b1       	in	r24, 0x01	; 1
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     8d4:	84 b1       	in	r24, 0x04	; 4
     8d6:	83 60       	ori	r24, 0x03	; 3
     8d8:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     8da:	84 b1       	in	r24, 0x04	; 4
     8dc:	8c 63       	ori	r24, 0x3C	; 60
     8de:	84 b9       	out	0x04, r24	; 4
}
     8e0:	0f 91       	pop	r16
     8e2:	ef 90       	pop	r14
     8e4:	df 90       	pop	r13
     8e6:	cf 90       	pop	r12
     8e8:	bf 90       	pop	r11
     8ea:	af 90       	pop	r10
     8ec:	9f 90       	pop	r9
     8ee:	8f 90       	pop	r8
     8f0:	08 95       	ret

000008f2 <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     8f2:	95 b1       	in	r25, 0x05	; 5
     8f4:	93 7c       	andi	r25, 0xC3	; 195
     8f6:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     8f8:	25 b1       	in	r18, 0x05	; 5
     8fa:	34 e0       	ldi	r19, 0x04	; 4
     8fc:	83 9f       	mul	r24, r19
     8fe:	c0 01       	movw	r24, r0
     900:	11 24       	eor	r1, r1
     902:	82 2b       	or	r24, r18
     904:	85 b9       	out	0x05, r24	; 5
     906:	08 95       	ret

00000908 <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     908:	85 b1       	in	r24, 0x05	; 5
     90a:	83 7c       	andi	r24, 0xC3	; 195
     90c:	85 b9       	out	0x05, r24	; 5
     90e:	08 95       	ret

00000910 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     910:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     912:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     914:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     916:	12 a2       	std	Z+34, r1	; 0x22
     918:	08 95       	ret

0000091a <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     91a:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     91c:	82 a1       	ldd	r24, Z+34	; 0x22
     91e:	88 23       	and	r24, r24
     920:	d9 f0       	breq	.+54     	; 0x958 <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     922:	81 a1       	ldd	r24, Z+33	; 0x21
     924:	df 01       	movw	r26, r30
     926:	a8 0f       	add	r26, r24
     928:	b1 1d       	adc	r27, r1
     92a:	8c 91       	ld	r24, X
     92c:	db 01       	movw	r26, r22
     92e:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     930:	21 a1       	ldd	r18, Z+33	; 0x21
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	2f 5f       	subi	r18, 0xFF	; 255
     936:	3f 4f       	sbci	r19, 0xFF	; 255
     938:	2f 71       	andi	r18, 0x1F	; 31
     93a:	30 78       	andi	r19, 0x80	; 128
     93c:	33 23       	and	r19, r19
     93e:	34 f4       	brge	.+12     	; 0x94c <buffer_get_item+0x32>
     940:	21 50       	subi	r18, 0x01	; 1
     942:	31 09       	sbc	r19, r1
     944:	20 6e       	ori	r18, 0xE0	; 224
     946:	3f 6f       	ori	r19, 0xFF	; 255
     948:	2f 5f       	subi	r18, 0xFF	; 255
     94a:	3f 4f       	sbci	r19, 0xFF	; 255
     94c:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     94e:	82 a1       	ldd	r24, Z+34	; 0x22
     950:	81 50       	subi	r24, 0x01	; 1
     952:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	08 95       	ret
	}
	return BUFFER_EMPTY;
     958:	81 e0       	ldi	r24, 0x01	; 1
}
     95a:	08 95       	ret

0000095c <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     95c:	fc 01       	movw	r30, r24
     95e:	42 a1       	ldd	r20, Z+34	; 0x22
     960:	40 32       	cpi	r20, 0x20	; 32
     962:	b8 f4       	brcc	.+46     	; 0x992 <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     964:	20 a1       	ldd	r18, Z+32	; 0x20
     966:	30 e0       	ldi	r19, 0x00	; 0
     968:	e2 0f       	add	r30, r18
     96a:	f3 1f       	adc	r31, r19
     96c:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     96e:	2f 5f       	subi	r18, 0xFF	; 255
     970:	3f 4f       	sbci	r19, 0xFF	; 255
     972:	2f 71       	andi	r18, 0x1F	; 31
     974:	30 78       	andi	r19, 0x80	; 128
     976:	33 23       	and	r19, r19
     978:	34 f4       	brge	.+12     	; 0x986 <buffer_put_item+0x2a>
     97a:	21 50       	subi	r18, 0x01	; 1
     97c:	31 09       	sbc	r19, r1
     97e:	20 6e       	ori	r18, 0xE0	; 224
     980:	3f 6f       	ori	r19, 0xFF	; 255
     982:	2f 5f       	subi	r18, 0xFF	; 255
     984:	3f 4f       	sbci	r19, 0xFF	; 255
     986:	fc 01       	movw	r30, r24
     988:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     98a:	4f 5f       	subi	r20, 0xFF	; 255
     98c:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	08 95       	ret
	}
	return BUFFER_FULL;
     992:	82 e0       	ldi	r24, 0x02	; 2
}
     994:	08 95       	ret

00000996 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     996:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     998:	03 96       	adiw	r24, 0x03	; 3
     99a:	92 83       	std	Z+2, r25	; 0x02
     99c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     99e:	2f ef       	ldi	r18, 0xFF	; 255
     9a0:	3f ef       	ldi	r19, 0xFF	; 255
     9a2:	34 83       	std	Z+4, r19	; 0x04
     9a4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9a6:	96 83       	std	Z+6, r25	; 0x06
     9a8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9aa:	90 87       	std	Z+8, r25	; 0x08
     9ac:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9ae:	10 82       	st	Z, r1
     9b0:	08 95       	ret

000009b2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     9b2:	fc 01       	movw	r30, r24
     9b4:	11 86       	std	Z+9, r1	; 0x09
     9b6:	10 86       	std	Z+8, r1	; 0x08
     9b8:	08 95       	ret

000009ba <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	9c 01       	movw	r18, r24
     9c0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9c2:	dc 01       	movw	r26, r24
     9c4:	11 96       	adiw	r26, 0x01	; 1
     9c6:	cd 91       	ld	r28, X+
     9c8:	dc 91       	ld	r29, X
     9ca:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9cc:	d3 83       	std	Z+3, r29	; 0x03
     9ce:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9d0:	8c 81       	ldd	r24, Y+4	; 0x04
     9d2:	9d 81       	ldd	r25, Y+5	; 0x05
     9d4:	95 83       	std	Z+5, r25	; 0x05
     9d6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9d8:	8c 81       	ldd	r24, Y+4	; 0x04
     9da:	9d 81       	ldd	r25, Y+5	; 0x05
     9dc:	dc 01       	movw	r26, r24
     9de:	13 96       	adiw	r26, 0x03	; 3
     9e0:	7c 93       	st	X, r23
     9e2:	6e 93       	st	-X, r22
     9e4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9e6:	7d 83       	std	Y+5, r23	; 0x05
     9e8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9ea:	31 87       	std	Z+9, r19	; 0x09
     9ec:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9ee:	f9 01       	movw	r30, r18
     9f0:	80 81       	ld	r24, Z
     9f2:	8f 5f       	subi	r24, 0xFF	; 255
     9f4:	80 83       	st	Z, r24
}
     9f6:	df 91       	pop	r29
     9f8:	cf 91       	pop	r28
     9fa:	08 95       	ret

000009fc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a02:	48 81       	ld	r20, Y
     a04:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a06:	4f 3f       	cpi	r20, 0xFF	; 255
     a08:	2f ef       	ldi	r18, 0xFF	; 255
     a0a:	52 07       	cpc	r21, r18
     a0c:	21 f4       	brne	.+8      	; 0xa16 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a0e:	fc 01       	movw	r30, r24
     a10:	a7 81       	ldd	r26, Z+7	; 0x07
     a12:	b0 85       	ldd	r27, Z+8	; 0x08
     a14:	0d c0       	rjmp	.+26     	; 0xa30 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     a16:	dc 01       	movw	r26, r24
     a18:	13 96       	adiw	r26, 0x03	; 3
     a1a:	01 c0       	rjmp	.+2      	; 0xa1e <vListInsert+0x22>
     a1c:	df 01       	movw	r26, r30
     a1e:	12 96       	adiw	r26, 0x02	; 2
     a20:	ed 91       	ld	r30, X+
     a22:	fc 91       	ld	r31, X
     a24:	13 97       	sbiw	r26, 0x03	; 3
     a26:	20 81       	ld	r18, Z
     a28:	31 81       	ldd	r19, Z+1	; 0x01
     a2a:	42 17       	cp	r20, r18
     a2c:	53 07       	cpc	r21, r19
     a2e:	b0 f7       	brcc	.-20     	; 0xa1c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a30:	12 96       	adiw	r26, 0x02	; 2
     a32:	ed 91       	ld	r30, X+
     a34:	fc 91       	ld	r31, X
     a36:	13 97       	sbiw	r26, 0x03	; 3
     a38:	fb 83       	std	Y+3, r31	; 0x03
     a3a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a3c:	d5 83       	std	Z+5, r29	; 0x05
     a3e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a40:	bd 83       	std	Y+5, r27	; 0x05
     a42:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a44:	13 96       	adiw	r26, 0x03	; 3
     a46:	dc 93       	st	X, r29
     a48:	ce 93       	st	-X, r28
     a4a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a4c:	99 87       	std	Y+9, r25	; 0x09
     a4e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a50:	fc 01       	movw	r30, r24
     a52:	20 81       	ld	r18, Z
     a54:	2f 5f       	subi	r18, 0xFF	; 255
     a56:	20 83       	st	Z, r18
}
     a58:	df 91       	pop	r29
     a5a:	cf 91       	pop	r28
     a5c:	08 95       	ret

00000a5e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a64:	a0 85       	ldd	r26, Z+8	; 0x08
     a66:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a68:	c2 81       	ldd	r28, Z+2	; 0x02
     a6a:	d3 81       	ldd	r29, Z+3	; 0x03
     a6c:	84 81       	ldd	r24, Z+4	; 0x04
     a6e:	95 81       	ldd	r25, Z+5	; 0x05
     a70:	9d 83       	std	Y+5, r25	; 0x05
     a72:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a74:	c4 81       	ldd	r28, Z+4	; 0x04
     a76:	d5 81       	ldd	r29, Z+5	; 0x05
     a78:	82 81       	ldd	r24, Z+2	; 0x02
     a7a:	93 81       	ldd	r25, Z+3	; 0x03
     a7c:	9b 83       	std	Y+3, r25	; 0x03
     a7e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a80:	11 96       	adiw	r26, 0x01	; 1
     a82:	8d 91       	ld	r24, X+
     a84:	9c 91       	ld	r25, X
     a86:	12 97       	sbiw	r26, 0x02	; 2
     a88:	e8 17       	cp	r30, r24
     a8a:	f9 07       	cpc	r31, r25
     a8c:	31 f4       	brne	.+12     	; 0xa9a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a8e:	84 81       	ldd	r24, Z+4	; 0x04
     a90:	95 81       	ldd	r25, Z+5	; 0x05
     a92:	12 96       	adiw	r26, 0x02	; 2
     a94:	9c 93       	st	X, r25
     a96:	8e 93       	st	-X, r24
     a98:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     a9a:	11 86       	std	Z+9, r1	; 0x09
     a9c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a9e:	8c 91       	ld	r24, X
     aa0:	81 50       	subi	r24, 0x01	; 1
     aa2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     aa4:	df 91       	pop	r29
     aa6:	cf 91       	pop	r28
     aa8:	08 95       	ret

00000aaa <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     aaa:	31 e1       	ldi	r19, 0x11	; 17
     aac:	fc 01       	movw	r30, r24
     aae:	30 83       	st	Z, r19
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	22 e2       	ldi	r18, 0x22	; 34
     ab4:	20 83       	st	Z, r18
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	a3 e3       	ldi	r26, 0x33	; 51
     aba:	a0 83       	st	Z, r26
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	60 83       	st	Z, r22
     ac0:	31 97       	sbiw	r30, 0x01	; 1
     ac2:	70 83       	st	Z, r23
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	10 82       	st	Z, r1
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	60 e8       	ldi	r22, 0x80	; 128
     acc:	60 83       	st	Z, r22
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	10 82       	st	Z, r1
     ad2:	31 97       	sbiw	r30, 0x01	; 1
     ad4:	62 e0       	ldi	r22, 0x02	; 2
     ad6:	60 83       	st	Z, r22
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	63 e0       	ldi	r22, 0x03	; 3
     adc:	60 83       	st	Z, r22
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	64 e0       	ldi	r22, 0x04	; 4
     ae2:	60 83       	st	Z, r22
     ae4:	31 97       	sbiw	r30, 0x01	; 1
     ae6:	65 e0       	ldi	r22, 0x05	; 5
     ae8:	60 83       	st	Z, r22
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	66 e0       	ldi	r22, 0x06	; 6
     aee:	60 83       	st	Z, r22
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	67 e0       	ldi	r22, 0x07	; 7
     af4:	60 83       	st	Z, r22
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	68 e0       	ldi	r22, 0x08	; 8
     afa:	60 83       	st	Z, r22
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	69 e0       	ldi	r22, 0x09	; 9
     b00:	60 83       	st	Z, r22
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	60 e1       	ldi	r22, 0x10	; 16
     b06:	60 83       	st	Z, r22
     b08:	31 97       	sbiw	r30, 0x01	; 1
     b0a:	30 83       	st	Z, r19
     b0c:	31 97       	sbiw	r30, 0x01	; 1
     b0e:	32 e1       	ldi	r19, 0x12	; 18
     b10:	30 83       	st	Z, r19
     b12:	31 97       	sbiw	r30, 0x01	; 1
     b14:	33 e1       	ldi	r19, 0x13	; 19
     b16:	30 83       	st	Z, r19
     b18:	31 97       	sbiw	r30, 0x01	; 1
     b1a:	34 e1       	ldi	r19, 0x14	; 20
     b1c:	30 83       	st	Z, r19
     b1e:	31 97       	sbiw	r30, 0x01	; 1
     b20:	35 e1       	ldi	r19, 0x15	; 21
     b22:	30 83       	st	Z, r19
     b24:	31 97       	sbiw	r30, 0x01	; 1
     b26:	36 e1       	ldi	r19, 0x16	; 22
     b28:	30 83       	st	Z, r19
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	37 e1       	ldi	r19, 0x17	; 23
     b2e:	30 83       	st	Z, r19
     b30:	31 97       	sbiw	r30, 0x01	; 1
     b32:	38 e1       	ldi	r19, 0x18	; 24
     b34:	30 83       	st	Z, r19
     b36:	31 97       	sbiw	r30, 0x01	; 1
     b38:	39 e1       	ldi	r19, 0x19	; 25
     b3a:	30 83       	st	Z, r19
     b3c:	31 97       	sbiw	r30, 0x01	; 1
     b3e:	30 e2       	ldi	r19, 0x20	; 32
     b40:	30 83       	st	Z, r19
     b42:	31 97       	sbiw	r30, 0x01	; 1
     b44:	31 e2       	ldi	r19, 0x21	; 33
     b46:	30 83       	st	Z, r19
     b48:	31 97       	sbiw	r30, 0x01	; 1
     b4a:	20 83       	st	Z, r18
     b4c:	31 97       	sbiw	r30, 0x01	; 1
     b4e:	23 e2       	ldi	r18, 0x23	; 35
     b50:	20 83       	st	Z, r18
     b52:	31 97       	sbiw	r30, 0x01	; 1
     b54:	40 83       	st	Z, r20
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	50 83       	st	Z, r21
     b5a:	31 97       	sbiw	r30, 0x01	; 1
     b5c:	26 e2       	ldi	r18, 0x26	; 38
     b5e:	20 83       	st	Z, r18
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	27 e2       	ldi	r18, 0x27	; 39
     b64:	20 83       	st	Z, r18
     b66:	31 97       	sbiw	r30, 0x01	; 1
     b68:	28 e2       	ldi	r18, 0x28	; 40
     b6a:	20 83       	st	Z, r18
     b6c:	31 97       	sbiw	r30, 0x01	; 1
     b6e:	29 e2       	ldi	r18, 0x29	; 41
     b70:	20 83       	st	Z, r18
     b72:	31 97       	sbiw	r30, 0x01	; 1
     b74:	20 e3       	ldi	r18, 0x30	; 48
     b76:	20 83       	st	Z, r18
     b78:	31 97       	sbiw	r30, 0x01	; 1
     b7a:	21 e3       	ldi	r18, 0x31	; 49
     b7c:	20 83       	st	Z, r18
     b7e:	86 97       	sbiw	r24, 0x26	; 38
     b80:	08 95       	ret

00000b82 <xPortStartScheduler>:
     b82:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     b86:	85 ee       	ldi	r24, 0xE5	; 229
     b88:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     b8c:	8b e0       	ldi	r24, 0x0B	; 11
     b8e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     b92:	ef e6       	ldi	r30, 0x6F	; 111
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	80 81       	ld	r24, Z
     b98:	82 60       	ori	r24, 0x02	; 2
     b9a:	80 83       	st	Z, r24
     b9c:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
     ba0:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
     ba4:	cd 91       	ld	r28, X+
     ba6:	cd bf       	out	0x3d, r28	; 61
     ba8:	dd 91       	ld	r29, X+
     baa:	de bf       	out	0x3e, r29	; 62
     bac:	ff 91       	pop	r31
     bae:	ef 91       	pop	r30
     bb0:	df 91       	pop	r29
     bb2:	cf 91       	pop	r28
     bb4:	bf 91       	pop	r27
     bb6:	af 91       	pop	r26
     bb8:	9f 91       	pop	r25
     bba:	8f 91       	pop	r24
     bbc:	7f 91       	pop	r23
     bbe:	6f 91       	pop	r22
     bc0:	5f 91       	pop	r21
     bc2:	4f 91       	pop	r20
     bc4:	3f 91       	pop	r19
     bc6:	2f 91       	pop	r18
     bc8:	1f 91       	pop	r17
     bca:	0f 91       	pop	r16
     bcc:	ff 90       	pop	r15
     bce:	ef 90       	pop	r14
     bd0:	df 90       	pop	r13
     bd2:	cf 90       	pop	r12
     bd4:	bf 90       	pop	r11
     bd6:	af 90       	pop	r10
     bd8:	9f 90       	pop	r9
     bda:	8f 90       	pop	r8
     bdc:	7f 90       	pop	r7
     bde:	6f 90       	pop	r6
     be0:	5f 90       	pop	r5
     be2:	4f 90       	pop	r4
     be4:	3f 90       	pop	r3
     be6:	2f 90       	pop	r2
     be8:	1f 90       	pop	r1
     bea:	0f 90       	pop	r0
     bec:	0f be       	out	0x3f, r0	; 63
     bee:	0f 90       	pop	r0
     bf0:	08 95       	ret
     bf2:	81 e0       	ldi	r24, 0x01	; 1
     bf4:	08 95       	ret

00000bf6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     bf6:	0f 92       	push	r0
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
     bfe:	1f 92       	push	r1
     c00:	11 24       	eor	r1, r1
     c02:	2f 92       	push	r2
     c04:	3f 92       	push	r3
     c06:	4f 92       	push	r4
     c08:	5f 92       	push	r5
     c0a:	6f 92       	push	r6
     c0c:	7f 92       	push	r7
     c0e:	8f 92       	push	r8
     c10:	9f 92       	push	r9
     c12:	af 92       	push	r10
     c14:	bf 92       	push	r11
     c16:	cf 92       	push	r12
     c18:	df 92       	push	r13
     c1a:	ef 92       	push	r14
     c1c:	ff 92       	push	r15
     c1e:	0f 93       	push	r16
     c20:	1f 93       	push	r17
     c22:	2f 93       	push	r18
     c24:	3f 93       	push	r19
     c26:	4f 93       	push	r20
     c28:	5f 93       	push	r21
     c2a:	6f 93       	push	r22
     c2c:	7f 93       	push	r23
     c2e:	8f 93       	push	r24
     c30:	9f 93       	push	r25
     c32:	af 93       	push	r26
     c34:	bf 93       	push	r27
     c36:	cf 93       	push	r28
     c38:	df 93       	push	r29
     c3a:	ef 93       	push	r30
     c3c:	ff 93       	push	r31
     c3e:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
     c42:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
     c46:	0d b6       	in	r0, 0x3d	; 61
     c48:	0d 92       	st	X+, r0
     c4a:	0e b6       	in	r0, 0x3e	; 62
     c4c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c4e:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c52:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
     c56:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
     c5a:	cd 91       	ld	r28, X+
     c5c:	cd bf       	out	0x3d, r28	; 61
     c5e:	dd 91       	ld	r29, X+
     c60:	de bf       	out	0x3e, r29	; 62
     c62:	ff 91       	pop	r31
     c64:	ef 91       	pop	r30
     c66:	df 91       	pop	r29
     c68:	cf 91       	pop	r28
     c6a:	bf 91       	pop	r27
     c6c:	af 91       	pop	r26
     c6e:	9f 91       	pop	r25
     c70:	8f 91       	pop	r24
     c72:	7f 91       	pop	r23
     c74:	6f 91       	pop	r22
     c76:	5f 91       	pop	r21
     c78:	4f 91       	pop	r20
     c7a:	3f 91       	pop	r19
     c7c:	2f 91       	pop	r18
     c7e:	1f 91       	pop	r17
     c80:	0f 91       	pop	r16
     c82:	ff 90       	pop	r15
     c84:	ef 90       	pop	r14
     c86:	df 90       	pop	r13
     c88:	cf 90       	pop	r12
     c8a:	bf 90       	pop	r11
     c8c:	af 90       	pop	r10
     c8e:	9f 90       	pop	r9
     c90:	8f 90       	pop	r8
     c92:	7f 90       	pop	r7
     c94:	6f 90       	pop	r6
     c96:	5f 90       	pop	r5
     c98:	4f 90       	pop	r4
     c9a:	3f 90       	pop	r3
     c9c:	2f 90       	pop	r2
     c9e:	1f 90       	pop	r1
     ca0:	0f 90       	pop	r0
     ca2:	0f be       	out	0x3f, r0	; 63
     ca4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ca6:	08 95       	ret

00000ca8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ca8:	0f 92       	push	r0
     caa:	0f b6       	in	r0, 0x3f	; 63
     cac:	f8 94       	cli
     cae:	0f 92       	push	r0
     cb0:	1f 92       	push	r1
     cb2:	11 24       	eor	r1, r1
     cb4:	2f 92       	push	r2
     cb6:	3f 92       	push	r3
     cb8:	4f 92       	push	r4
     cba:	5f 92       	push	r5
     cbc:	6f 92       	push	r6
     cbe:	7f 92       	push	r7
     cc0:	8f 92       	push	r8
     cc2:	9f 92       	push	r9
     cc4:	af 92       	push	r10
     cc6:	bf 92       	push	r11
     cc8:	cf 92       	push	r12
     cca:	df 92       	push	r13
     ccc:	ef 92       	push	r14
     cce:	ff 92       	push	r15
     cd0:	0f 93       	push	r16
     cd2:	1f 93       	push	r17
     cd4:	2f 93       	push	r18
     cd6:	3f 93       	push	r19
     cd8:	4f 93       	push	r20
     cda:	5f 93       	push	r21
     cdc:	6f 93       	push	r22
     cde:	7f 93       	push	r23
     ce0:	8f 93       	push	r24
     ce2:	9f 93       	push	r25
     ce4:	af 93       	push	r26
     ce6:	bf 93       	push	r27
     ce8:	cf 93       	push	r28
     cea:	df 93       	push	r29
     cec:	ef 93       	push	r30
     cee:	ff 93       	push	r31
     cf0:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
     cf4:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
     cf8:	0d b6       	in	r0, 0x3d	; 61
     cfa:	0d 92       	st	X+, r0
     cfc:	0e b6       	in	r0, 0x3e	; 62
     cfe:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d00:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <xTaskIncrementTick>
     d04:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     d06:	0e 94 eb 0e 	call	0x1dd6	; 0x1dd6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d0a:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
     d0e:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
     d12:	cd 91       	ld	r28, X+
     d14:	cd bf       	out	0x3d, r28	; 61
     d16:	dd 91       	ld	r29, X+
     d18:	de bf       	out	0x3e, r29	; 62
     d1a:	ff 91       	pop	r31
     d1c:	ef 91       	pop	r30
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	bf 91       	pop	r27
     d24:	af 91       	pop	r26
     d26:	9f 91       	pop	r25
     d28:	8f 91       	pop	r24
     d2a:	7f 91       	pop	r23
     d2c:	6f 91       	pop	r22
     d2e:	5f 91       	pop	r21
     d30:	4f 91       	pop	r20
     d32:	3f 91       	pop	r19
     d34:	2f 91       	pop	r18
     d36:	1f 91       	pop	r17
     d38:	0f 91       	pop	r16
     d3a:	ff 90       	pop	r15
     d3c:	ef 90       	pop	r14
     d3e:	df 90       	pop	r13
     d40:	cf 90       	pop	r12
     d42:	bf 90       	pop	r11
     d44:	af 90       	pop	r10
     d46:	9f 90       	pop	r9
     d48:	8f 90       	pop	r8
     d4a:	7f 90       	pop	r7
     d4c:	6f 90       	pop	r6
     d4e:	5f 90       	pop	r5
     d50:	4f 90       	pop	r4
     d52:	3f 90       	pop	r3
     d54:	2f 90       	pop	r2
     d56:	1f 90       	pop	r1
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63
     d5c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d5e:	08 95       	ret

00000d60 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     d60:	0e 94 54 06 	call	0xca8	; 0xca8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     d64:	18 95       	reti

00000d66 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     d66:	cf 93       	push	r28
     d68:	df 93       	push	r29
     d6a:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     d6c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     d70:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pucAlignedHeap.2084>
     d74:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pucAlignedHeap.2084+0x1>
     d78:	89 2b       	or	r24, r25
     d7a:	31 f4       	brne	.+12     	; 0xd88 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     d7c:	82 eb       	ldi	r24, 0xB2	; 178
     d7e:	91 e0       	ldi	r25, 0x01	; 1
     d80:	90 93 ae 01 	sts	0x01AE, r25	; 0x8001ae <pucAlignedHeap.2084+0x1>
     d84:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     d88:	20 91 af 01 	lds	r18, 0x01AF	; 0x8001af <xNextFreeByte>
     d8c:	30 91 b0 01 	lds	r19, 0x01B0	; 0x8001b0 <xNextFreeByte+0x1>
     d90:	c9 01       	movw	r24, r18
     d92:	8c 0f       	add	r24, r28
     d94:	9d 1f       	adc	r25, r29
     d96:	87 3e       	cpi	r24, 0xE7	; 231
     d98:	43 e0       	ldi	r20, 0x03	; 3
     d9a:	94 07       	cpc	r25, r20
     d9c:	70 f4       	brcc	.+28     	; 0xdba <pvPortMalloc+0x54>
     d9e:	28 17       	cp	r18, r24
     da0:	39 07       	cpc	r19, r25
     da2:	70 f4       	brcc	.+28     	; 0xdc0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     da4:	c0 91 ad 01 	lds	r28, 0x01AD	; 0x8001ad <pucAlignedHeap.2084>
     da8:	d0 91 ae 01 	lds	r29, 0x01AE	; 0x8001ae <pucAlignedHeap.2084+0x1>
     dac:	c2 0f       	add	r28, r18
     dae:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     db0:	90 93 b0 01 	sts	0x01B0, r25	; 0x8001b0 <xNextFreeByte+0x1>
     db4:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <xNextFreeByte>
     db8:	05 c0       	rjmp	.+10     	; 0xdc4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     dba:	c0 e0       	ldi	r28, 0x00	; 0
     dbc:	d0 e0       	ldi	r29, 0x00	; 0
     dbe:	02 c0       	rjmp	.+4      	; 0xdc4 <pvPortMalloc+0x5e>
     dc0:	c0 e0       	ldi	r28, 0x00	; 0
     dc2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     dc4:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     dc8:	ce 01       	movw	r24, r28
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	08 95       	ret

00000dd0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     dd0:	08 95       	ret

00000dd2 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     dd2:	4f 92       	push	r4
     dd4:	5f 92       	push	r5
     dd6:	6f 92       	push	r6
     dd8:	7f 92       	push	r7
     dda:	8f 92       	push	r8
     ddc:	9f 92       	push	r9
     dde:	af 92       	push	r10
     de0:	bf 92       	push	r11
     de2:	cf 92       	push	r12
     de4:	df 92       	push	r13
     de6:	ff 92       	push	r15
     de8:	0f 93       	push	r16
     dea:	1f 93       	push	r17
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	f8 2e       	mov	r15, r24
     df6:	2a 01       	movw	r4, r20
     df8:	3b 01       	movw	r6, r22
     dfa:	88 e0       	ldi	r24, 0x08	; 8
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <malloc>
     e02:	8c 01       	movw	r16, r24
     e04:	8f 2d       	mov	r24, r15
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	88 0f       	add	r24, r24
     e0a:	99 1f       	adc	r25, r25
     e0c:	fc 01       	movw	r30, r24
     e0e:	e7 56       	subi	r30, 0x67	; 103
     e10:	fa 4f       	sbci	r31, 0xFA	; 250
     e12:	11 83       	std	Z+1, r17	; 0x01
     e14:	00 83       	st	Z, r16
     e16:	fc 01       	movw	r30, r24
     e18:	e6 5f       	subi	r30, 0xF6	; 246
     e1a:	fe 4f       	sbci	r31, 0xFE	; 254
     e1c:	80 81       	ld	r24, Z
     e1e:	91 81       	ldd	r25, Z+1	; 0x01
     e20:	d8 01       	movw	r26, r16
     e22:	11 96       	adiw	r26, 0x01	; 1
     e24:	9c 93       	st	X, r25
     e26:	8e 93       	st	-X, r24
     e28:	13 96       	adiw	r26, 0x03	; 3
     e2a:	bc 92       	st	X, r11
     e2c:	ae 92       	st	-X, r10
     e2e:	12 97       	sbiw	r26, 0x02	; 2
     e30:	15 96       	adiw	r26, 0x05	; 5
     e32:	dc 92       	st	X, r13
     e34:	ce 92       	st	-X, r12
     e36:	14 97       	sbiw	r26, 0x04	; 4
     e38:	17 96       	adiw	r26, 0x07	; 7
     e3a:	9c 92       	st	X, r9
     e3c:	8e 92       	st	-X, r8
     e3e:	16 97       	sbiw	r26, 0x06	; 6
     e40:	ff b6       	in	r15, 0x3f	; 63
     e42:	f8 94       	cli
     e44:	ed 91       	ld	r30, X+
     e46:	fc 91       	ld	r31, X
     e48:	11 97       	sbiw	r26, 0x01	; 1
     e4a:	36 97       	sbiw	r30, 0x06	; 6
     e4c:	80 81       	ld	r24, Z
     e4e:	82 60       	ori	r24, 0x02	; 2
     e50:	80 83       	st	Z, r24
     e52:	cd 90       	ld	r12, X+
     e54:	dc 90       	ld	r13, X
     e56:	d3 01       	movw	r26, r6
     e58:	c2 01       	movw	r24, r4
     e5a:	88 0f       	add	r24, r24
     e5c:	99 1f       	adc	r25, r25
     e5e:	aa 1f       	adc	r26, r26
     e60:	bb 1f       	adc	r27, r27
     e62:	88 0f       	add	r24, r24
     e64:	99 1f       	adc	r25, r25
     e66:	aa 1f       	adc	r26, r26
     e68:	bb 1f       	adc	r27, r27
     e6a:	9c 01       	movw	r18, r24
     e6c:	ad 01       	movw	r20, r26
     e6e:	22 0f       	add	r18, r18
     e70:	33 1f       	adc	r19, r19
     e72:	44 1f       	adc	r20, r20
     e74:	55 1f       	adc	r21, r21
     e76:	60 e0       	ldi	r22, 0x00	; 0
     e78:	70 e0       	ldi	r23, 0x00	; 0
     e7a:	81 ee       	ldi	r24, 0xE1	; 225
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	0e 94 ae 10 	call	0x215c	; 0x215c <__udivmodsi4>
     e82:	21 50       	subi	r18, 0x01	; 1
     e84:	f6 01       	movw	r30, r12
     e86:	32 97       	sbiw	r30, 0x02	; 2
     e88:	20 83       	st	Z, r18
     e8a:	d8 01       	movw	r26, r16
     e8c:	ed 91       	ld	r30, X+
     e8e:	fc 91       	ld	r31, X
     e90:	11 97       	sbiw	r26, 0x01	; 1
     e92:	35 97       	sbiw	r30, 0x05	; 5
     e94:	88 e9       	ldi	r24, 0x98	; 152
     e96:	80 83       	st	Z, r24
     e98:	ed 91       	ld	r30, X+
     e9a:	fc 91       	ld	r31, X
     e9c:	34 97       	sbiw	r30, 0x04	; 4
     e9e:	86 e0       	ldi	r24, 0x06	; 6
     ea0:	80 83       	st	Z, r24
     ea2:	ff be       	out	0x3f, r15	; 63
     ea4:	c8 01       	movw	r24, r16
     ea6:	df 91       	pop	r29
     ea8:	cf 91       	pop	r28
     eaa:	1f 91       	pop	r17
     eac:	0f 91       	pop	r16
     eae:	ff 90       	pop	r15
     eb0:	df 90       	pop	r13
     eb2:	cf 90       	pop	r12
     eb4:	bf 90       	pop	r11
     eb6:	af 90       	pop	r10
     eb8:	9f 90       	pop	r9
     eba:	8f 90       	pop	r8
     ebc:	7f 90       	pop	r7
     ebe:	6f 90       	pop	r6
     ec0:	5f 90       	pop	r5
     ec2:	4f 90       	pop	r4
     ec4:	08 95       	ret

00000ec6 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     ec6:	ef 92       	push	r14
     ec8:	ff 92       	push	r15
     eca:	0f 93       	push	r16
     ecc:	1f 93       	push	r17
     ece:	cf 93       	push	r28
     ed0:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     ed2:	fc 01       	movw	r30, r24
     ed4:	a2 81       	ldd	r26, Z+2	; 0x02
     ed6:	b3 81       	ldd	r27, Z+3	; 0x03
     ed8:	10 97       	sbiw	r26, 0x00	; 0
     eda:	79 f0       	breq	.+30     	; 0xefa <serial_send_bytes+0x34>
     edc:	e4 2f       	mov	r30, r20
     ede:	f0 e0       	ldi	r31, 0x00	; 0
     ee0:	92 96       	adiw	r26, 0x22	; 34
     ee2:	5c 91       	ld	r21, X
     ee4:	20 e2       	ldi	r18, 0x20	; 32
     ee6:	30 e0       	ldi	r19, 0x00	; 0
     ee8:	25 1b       	sub	r18, r21
     eea:	31 09       	sbc	r19, r1
     eec:	2e 17       	cp	r18, r30
     eee:	3f 07       	cpc	r19, r31
     ef0:	1c f1       	brlt	.+70     	; 0xf38 <serial_send_bytes+0x72>
     ef2:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     ef4:	41 11       	cpse	r20, r1
     ef6:	04 c0       	rjmp	.+8      	; 0xf00 <serial_send_bytes+0x3a>
     ef8:	16 c0       	rjmp	.+44     	; 0xf26 <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     efa:	42 30       	cpi	r20, 0x02	; 2
     efc:	f8 f4       	brcc	.+62     	; 0xf3c <serial_send_bytes+0x76>
     efe:	f9 cf       	rjmp	.-14     	; 0xef2 <serial_send_bytes+0x2c>
     f00:	eb 01       	movw	r28, r22
     f02:	41 50       	subi	r20, 0x01	; 1
     f04:	04 2f       	mov	r16, r20
     f06:	10 e0       	ldi	r17, 0x00	; 0
     f08:	0f 5f       	subi	r16, 0xFF	; 255
     f0a:	1f 4f       	sbci	r17, 0xFF	; 255
     f0c:	06 0f       	add	r16, r22
     f0e:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     f10:	69 91       	ld	r22, Y+
     f12:	d7 01       	movw	r26, r14
     f14:	12 96       	adiw	r26, 0x02	; 2
     f16:	8d 91       	ld	r24, X+
     f18:	9c 91       	ld	r25, X
     f1a:	13 97       	sbiw	r26, 0x03	; 3
     f1c:	0e 94 ae 04 	call	0x95c	; 0x95c <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     f20:	c0 17       	cp	r28, r16
     f22:	d1 07       	cpc	r29, r17
     f24:	a9 f7       	brne	.-22     	; 0xf10 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     f26:	d7 01       	movw	r26, r14
     f28:	ed 91       	ld	r30, X+
     f2a:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     f2c:	35 97       	sbiw	r30, 0x05	; 5
     f2e:	80 81       	ld	r24, Z
     f30:	80 62       	ori	r24, 0x20	; 32
     f32:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	03 c0       	rjmp	.+6      	; 0xf3e <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     f38:	82 e0       	ldi	r24, 0x02	; 2
     f3a:	01 c0       	rjmp	.+2      	; 0xf3e <serial_send_bytes+0x78>
     f3c:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	1f 91       	pop	r17
     f44:	0f 91       	pop	r16
     f46:	ff 90       	pop	r15
     f48:	ef 90       	pop	r14
     f4a:	08 95       	ret

00000f4c <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     f4c:	1f 92       	push	r1
     f4e:	0f 92       	push	r0
     f50:	0f b6       	in	r0, 0x3f	; 63
     f52:	0f 92       	push	r0
     f54:	11 24       	eor	r1, r1
     f56:	2f 93       	push	r18
     f58:	3f 93       	push	r19
     f5a:	4f 93       	push	r20
     f5c:	5f 93       	push	r21
     f5e:	6f 93       	push	r22
     f60:	7f 93       	push	r23
     f62:	8f 93       	push	r24
     f64:	9f 93       	push	r25
     f66:	af 93       	push	r26
     f68:	bf 93       	push	r27
     f6a:	cf 93       	push	r28
     f6c:	ef 93       	push	r30
     f6e:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     f70:	e0 91 99 05 	lds	r30, 0x0599	; 0x800599 <_ser_handle>
     f74:	f0 91 9a 05 	lds	r31, 0x059A	; 0x80059a <_ser_handle+0x1>
     f78:	30 97       	sbiw	r30, 0x00	; 0
     f7a:	a1 f0       	breq	.+40     	; 0xfa4 <__vector_20+0x58>
		item = UDR0;
     f7c:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     f80:	6c 2f       	mov	r22, r28
     f82:	84 81       	ldd	r24, Z+4	; 0x04
     f84:	95 81       	ldd	r25, Z+5	; 0x05
     f86:	0e 94 ae 04 	call	0x95c	; 0x95c <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     f8a:	80 91 99 05 	lds	r24, 0x0599	; 0x800599 <_ser_handle>
     f8e:	90 91 9a 05 	lds	r25, 0x059A	; 0x80059a <_ser_handle+0x1>
     f92:	dc 01       	movw	r26, r24
     f94:	16 96       	adiw	r26, 0x06	; 6
     f96:	ed 91       	ld	r30, X+
     f98:	fc 91       	ld	r31, X
     f9a:	17 97       	sbiw	r26, 0x07	; 7
     f9c:	30 97       	sbiw	r30, 0x00	; 0
     f9e:	11 f0       	breq	.+4      	; 0xfa4 <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     fa0:	6c 2f       	mov	r22, r28
     fa2:	09 95       	icall
		}
	}
}
     fa4:	ff 91       	pop	r31
     fa6:	ef 91       	pop	r30
     fa8:	cf 91       	pop	r28
     faa:	bf 91       	pop	r27
     fac:	af 91       	pop	r26
     fae:	9f 91       	pop	r25
     fb0:	8f 91       	pop	r24
     fb2:	7f 91       	pop	r23
     fb4:	6f 91       	pop	r22
     fb6:	5f 91       	pop	r21
     fb8:	4f 91       	pop	r20
     fba:	3f 91       	pop	r19
     fbc:	2f 91       	pop	r18
     fbe:	0f 90       	pop	r0
     fc0:	0f be       	out	0x3f, r0	; 63
     fc2:	0f 90       	pop	r0
     fc4:	1f 90       	pop	r1
     fc6:	18 95       	reti

00000fc8 <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     fc8:	1f 92       	push	r1
     fca:	0f 92       	push	r0
     fcc:	0f b6       	in	r0, 0x3f	; 63
     fce:	0f 92       	push	r0
     fd0:	11 24       	eor	r1, r1
     fd2:	2f 93       	push	r18
     fd4:	3f 93       	push	r19
     fd6:	4f 93       	push	r20
     fd8:	5f 93       	push	r21
     fda:	6f 93       	push	r22
     fdc:	7f 93       	push	r23
     fde:	8f 93       	push	r24
     fe0:	9f 93       	push	r25
     fe2:	af 93       	push	r26
     fe4:	bf 93       	push	r27
     fe6:	ef 93       	push	r30
     fe8:	ff 93       	push	r31
     fea:	cf 93       	push	r28
     fec:	df 93       	push	r29
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     ff4:	e0 91 99 05 	lds	r30, 0x0599	; 0x800599 <_ser_handle>
     ff8:	f0 91 9a 05 	lds	r31, 0x059A	; 0x80059a <_ser_handle+0x1>
     ffc:	30 97       	sbiw	r30, 0x00	; 0
     ffe:	99 f0       	breq	.+38     	; 0x1026 <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    1000:	be 01       	movw	r22, r28
    1002:	6f 5f       	subi	r22, 0xFF	; 255
    1004:	7f 4f       	sbci	r23, 0xFF	; 255
    1006:	82 81       	ldd	r24, Z+2	; 0x02
    1008:	93 81       	ldd	r25, Z+3	; 0x03
    100a:	0e 94 8d 04 	call	0x91a	; 0x91a <buffer_get_item>
    100e:	81 11       	cpse	r24, r1
    1010:	04 c0       	rjmp	.+8      	; 0x101a <__vector_21+0x52>
			UDR0 = item;
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1018:	0b c0       	rjmp	.+22     	; 0x1030 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    101a:	e1 ec       	ldi	r30, 0xC1	; 193
    101c:	f0 e0       	ldi	r31, 0x00	; 0
    101e:	80 81       	ld	r24, Z
    1020:	8f 7d       	andi	r24, 0xDF	; 223
    1022:	80 83       	st	Z, r24
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    1026:	e1 ec       	ldi	r30, 0xC1	; 193
    1028:	f0 e0       	ldi	r31, 0x00	; 0
    102a:	80 81       	ld	r24, Z
    102c:	8f 7d       	andi	r24, 0xDF	; 223
    102e:	80 83       	st	Z, r24
	}
}
    1030:	0f 90       	pop	r0
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	ff 91       	pop	r31
    1038:	ef 91       	pop	r30
    103a:	bf 91       	pop	r27
    103c:	af 91       	pop	r26
    103e:	9f 91       	pop	r25
    1040:	8f 91       	pop	r24
    1042:	7f 91       	pop	r23
    1044:	6f 91       	pop	r22
    1046:	5f 91       	pop	r21
    1048:	4f 91       	pop	r20
    104a:	3f 91       	pop	r19
    104c:	2f 91       	pop	r18
    104e:	0f 90       	pop	r0
    1050:	0f be       	out	0x3f, r0	; 63
    1052:	0f 90       	pop	r0
    1054:	1f 90       	pop	r1
    1056:	18 95       	reti

00001058 <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    1058:	1f 92       	push	r1
    105a:	0f 92       	push	r0
    105c:	0f b6       	in	r0, 0x3f	; 63
    105e:	0f 92       	push	r0
    1060:	11 24       	eor	r1, r1
    1062:	2f 93       	push	r18
    1064:	3f 93       	push	r19
    1066:	4f 93       	push	r20
    1068:	5f 93       	push	r21
    106a:	6f 93       	push	r22
    106c:	7f 93       	push	r23
    106e:	8f 93       	push	r24
    1070:	9f 93       	push	r25
    1072:	af 93       	push	r26
    1074:	bf 93       	push	r27
    1076:	cf 93       	push	r28
    1078:	ef 93       	push	r30
    107a:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    107c:	e0 91 9b 05 	lds	r30, 0x059B	; 0x80059b <_ser_handle+0x2>
    1080:	f0 91 9c 05 	lds	r31, 0x059C	; 0x80059c <_ser_handle+0x3>
    1084:	30 97       	sbiw	r30, 0x00	; 0
    1086:	a1 f0       	breq	.+40     	; 0x10b0 <__vector_28+0x58>
		item = UDR1;
    1088:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    108c:	6c 2f       	mov	r22, r28
    108e:	84 81       	ldd	r24, Z+4	; 0x04
    1090:	95 81       	ldd	r25, Z+5	; 0x05
    1092:	0e 94 ae 04 	call	0x95c	; 0x95c <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    1096:	80 91 9b 05 	lds	r24, 0x059B	; 0x80059b <_ser_handle+0x2>
    109a:	90 91 9c 05 	lds	r25, 0x059C	; 0x80059c <_ser_handle+0x3>
    109e:	dc 01       	movw	r26, r24
    10a0:	16 96       	adiw	r26, 0x06	; 6
    10a2:	ed 91       	ld	r30, X+
    10a4:	fc 91       	ld	r31, X
    10a6:	17 97       	sbiw	r26, 0x07	; 7
    10a8:	30 97       	sbiw	r30, 0x00	; 0
    10aa:	11 f0       	breq	.+4      	; 0x10b0 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    10ac:	6c 2f       	mov	r22, r28
    10ae:	09 95       	icall
		}
	}
}
    10b0:	ff 91       	pop	r31
    10b2:	ef 91       	pop	r30
    10b4:	cf 91       	pop	r28
    10b6:	bf 91       	pop	r27
    10b8:	af 91       	pop	r26
    10ba:	9f 91       	pop	r25
    10bc:	8f 91       	pop	r24
    10be:	7f 91       	pop	r23
    10c0:	6f 91       	pop	r22
    10c2:	5f 91       	pop	r21
    10c4:	4f 91       	pop	r20
    10c6:	3f 91       	pop	r19
    10c8:	2f 91       	pop	r18
    10ca:	0f 90       	pop	r0
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	0f 90       	pop	r0
    10d0:	1f 90       	pop	r1
    10d2:	18 95       	reti

000010d4 <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    10d4:	1f 92       	push	r1
    10d6:	0f 92       	push	r0
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	0f 92       	push	r0
    10dc:	11 24       	eor	r1, r1
    10de:	2f 93       	push	r18
    10e0:	3f 93       	push	r19
    10e2:	4f 93       	push	r20
    10e4:	5f 93       	push	r21
    10e6:	6f 93       	push	r22
    10e8:	7f 93       	push	r23
    10ea:	8f 93       	push	r24
    10ec:	9f 93       	push	r25
    10ee:	af 93       	push	r26
    10f0:	bf 93       	push	r27
    10f2:	ef 93       	push	r30
    10f4:	ff 93       	push	r31
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	1f 92       	push	r1
    10fc:	cd b7       	in	r28, 0x3d	; 61
    10fe:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    1100:	e0 91 9b 05 	lds	r30, 0x059B	; 0x80059b <_ser_handle+0x2>
    1104:	f0 91 9c 05 	lds	r31, 0x059C	; 0x80059c <_ser_handle+0x3>
    1108:	30 97       	sbiw	r30, 0x00	; 0
    110a:	99 f0       	breq	.+38     	; 0x1132 <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    110c:	be 01       	movw	r22, r28
    110e:	6f 5f       	subi	r22, 0xFF	; 255
    1110:	7f 4f       	sbci	r23, 0xFF	; 255
    1112:	82 81       	ldd	r24, Z+2	; 0x02
    1114:	93 81       	ldd	r25, Z+3	; 0x03
    1116:	0e 94 8d 04 	call	0x91a	; 0x91a <buffer_get_item>
    111a:	81 11       	cpse	r24, r1
    111c:	04 c0       	rjmp	.+8      	; 0x1126 <__vector_29+0x52>
			UDR1 = item;
    111e:	89 81       	ldd	r24, Y+1	; 0x01
    1120:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1124:	0b c0       	rjmp	.+22     	; 0x113c <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    1126:	e9 ec       	ldi	r30, 0xC9	; 201
    1128:	f0 e0       	ldi	r31, 0x00	; 0
    112a:	80 81       	ld	r24, Z
    112c:	8f 7d       	andi	r24, 0xDF	; 223
    112e:	80 83       	st	Z, r24
    1130:	05 c0       	rjmp	.+10     	; 0x113c <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    1132:	e9 ec       	ldi	r30, 0xC9	; 201
    1134:	f0 e0       	ldi	r31, 0x00	; 0
    1136:	80 81       	ld	r24, Z
    1138:	8f 7d       	andi	r24, 0xDF	; 223
    113a:	80 83       	st	Z, r24
	}
}
    113c:	0f 90       	pop	r0
    113e:	df 91       	pop	r29
    1140:	cf 91       	pop	r28
    1142:	ff 91       	pop	r31
    1144:	ef 91       	pop	r30
    1146:	bf 91       	pop	r27
    1148:	af 91       	pop	r26
    114a:	9f 91       	pop	r25
    114c:	8f 91       	pop	r24
    114e:	7f 91       	pop	r23
    1150:	6f 91       	pop	r22
    1152:	5f 91       	pop	r21
    1154:	4f 91       	pop	r20
    1156:	3f 91       	pop	r19
    1158:	2f 91       	pop	r18
    115a:	0f 90       	pop	r0
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	0f 90       	pop	r0
    1160:	1f 90       	pop	r1
    1162:	18 95       	reti

00001164 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1164:	0f 93       	push	r16
    1166:	1f 93       	push	r17
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	ec 01       	movw	r28, r24
    116e:	04 2f       	mov	r16, r20
    1170:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1172:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1174:	41 11       	cpse	r20, r1
    1176:	0c c0       	rjmp	.+24     	; 0x1190 <prvCopyDataToQueue+0x2c>
    1178:	88 81       	ld	r24, Y
    117a:	99 81       	ldd	r25, Y+1	; 0x01
    117c:	89 2b       	or	r24, r25
    117e:	09 f0       	breq	.+2      	; 0x1182 <prvCopyDataToQueue+0x1e>
    1180:	42 c0       	rjmp	.+132    	; 0x1206 <prvCopyDataToQueue+0xa2>
    1182:	8a 81       	ldd	r24, Y+2	; 0x02
    1184:	9b 81       	ldd	r25, Y+3	; 0x03
    1186:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <xTaskPriorityDisinherit>
    118a:	1b 82       	std	Y+3, r1	; 0x03
    118c:	1a 82       	std	Y+2, r1	; 0x02
    118e:	42 c0       	rjmp	.+132    	; 0x1214 <prvCopyDataToQueue+0xb0>
    1190:	01 11       	cpse	r16, r1
    1192:	17 c0       	rjmp	.+46     	; 0x11c2 <prvCopyDataToQueue+0x5e>
    1194:	50 e0       	ldi	r21, 0x00	; 0
    1196:	8c 81       	ldd	r24, Y+4	; 0x04
    1198:	9d 81       	ldd	r25, Y+5	; 0x05
    119a:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <memcpy>
    119e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11a0:	8c 81       	ldd	r24, Y+4	; 0x04
    11a2:	9d 81       	ldd	r25, Y+5	; 0x05
    11a4:	82 0f       	add	r24, r18
    11a6:	91 1d       	adc	r25, r1
    11a8:	9d 83       	std	Y+5, r25	; 0x05
    11aa:	8c 83       	std	Y+4, r24	; 0x04
    11ac:	2a 81       	ldd	r18, Y+2	; 0x02
    11ae:	3b 81       	ldd	r19, Y+3	; 0x03
    11b0:	82 17       	cp	r24, r18
    11b2:	93 07       	cpc	r25, r19
    11b4:	50 f1       	brcs	.+84     	; 0x120a <prvCopyDataToQueue+0xa6>
    11b6:	88 81       	ld	r24, Y
    11b8:	99 81       	ldd	r25, Y+1	; 0x01
    11ba:	9d 83       	std	Y+5, r25	; 0x05
    11bc:	8c 83       	std	Y+4, r24	; 0x04
    11be:	80 e0       	ldi	r24, 0x00	; 0
    11c0:	29 c0       	rjmp	.+82     	; 0x1214 <prvCopyDataToQueue+0xb0>
    11c2:	50 e0       	ldi	r21, 0x00	; 0
    11c4:	8e 81       	ldd	r24, Y+6	; 0x06
    11c6:	9f 81       	ldd	r25, Y+7	; 0x07
    11c8:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <memcpy>
    11cc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	91 95       	neg	r25
    11d2:	81 95       	neg	r24
    11d4:	91 09       	sbc	r25, r1
    11d6:	2e 81       	ldd	r18, Y+6	; 0x06
    11d8:	3f 81       	ldd	r19, Y+7	; 0x07
    11da:	28 0f       	add	r18, r24
    11dc:	39 1f       	adc	r19, r25
    11de:	3f 83       	std	Y+7, r19	; 0x07
    11e0:	2e 83       	std	Y+6, r18	; 0x06
    11e2:	48 81       	ld	r20, Y
    11e4:	59 81       	ldd	r21, Y+1	; 0x01
    11e6:	24 17       	cp	r18, r20
    11e8:	35 07       	cpc	r19, r21
    11ea:	30 f4       	brcc	.+12     	; 0x11f8 <prvCopyDataToQueue+0x94>
    11ec:	2a 81       	ldd	r18, Y+2	; 0x02
    11ee:	3b 81       	ldd	r19, Y+3	; 0x03
    11f0:	82 0f       	add	r24, r18
    11f2:	93 1f       	adc	r25, r19
    11f4:	9f 83       	std	Y+7, r25	; 0x07
    11f6:	8e 83       	std	Y+6, r24	; 0x06
    11f8:	02 30       	cpi	r16, 0x02	; 2
    11fa:	49 f4       	brne	.+18     	; 0x120e <prvCopyDataToQueue+0xaa>
    11fc:	11 23       	and	r17, r17
    11fe:	49 f0       	breq	.+18     	; 0x1212 <prvCopyDataToQueue+0xae>
    1200:	11 50       	subi	r17, 0x01	; 1
    1202:	80 e0       	ldi	r24, 0x00	; 0
    1204:	07 c0       	rjmp	.+14     	; 0x1214 <prvCopyDataToQueue+0xb0>
    1206:	80 e0       	ldi	r24, 0x00	; 0
    1208:	05 c0       	rjmp	.+10     	; 0x1214 <prvCopyDataToQueue+0xb0>
    120a:	80 e0       	ldi	r24, 0x00	; 0
    120c:	03 c0       	rjmp	.+6      	; 0x1214 <prvCopyDataToQueue+0xb0>
    120e:	80 e0       	ldi	r24, 0x00	; 0
    1210:	01 c0       	rjmp	.+2      	; 0x1214 <prvCopyDataToQueue+0xb0>
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	1f 5f       	subi	r17, 0xFF	; 255
    1216:	1a 8f       	std	Y+26, r17	; 0x1a
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	1f 91       	pop	r17
    121e:	0f 91       	pop	r16
    1220:	08 95       	ret

00001222 <prvCopyDataFromQueue>:
    1222:	fc 01       	movw	r30, r24
    1224:	44 8d       	ldd	r20, Z+28	; 0x1c
    1226:	44 23       	and	r20, r20
    1228:	a9 f0       	breq	.+42     	; 0x1254 <prvCopyDataFromQueue+0x32>
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	26 81       	ldd	r18, Z+6	; 0x06
    122e:	37 81       	ldd	r19, Z+7	; 0x07
    1230:	24 0f       	add	r18, r20
    1232:	35 1f       	adc	r19, r21
    1234:	37 83       	std	Z+7, r19	; 0x07
    1236:	26 83       	std	Z+6, r18	; 0x06
    1238:	82 81       	ldd	r24, Z+2	; 0x02
    123a:	93 81       	ldd	r25, Z+3	; 0x03
    123c:	28 17       	cp	r18, r24
    123e:	39 07       	cpc	r19, r25
    1240:	20 f0       	brcs	.+8      	; 0x124a <prvCopyDataFromQueue+0x28>
    1242:	80 81       	ld	r24, Z
    1244:	91 81       	ldd	r25, Z+1	; 0x01
    1246:	97 83       	std	Z+7, r25	; 0x07
    1248:	86 83       	std	Z+6, r24	; 0x06
    124a:	cb 01       	movw	r24, r22
    124c:	66 81       	ldd	r22, Z+6	; 0x06
    124e:	77 81       	ldd	r23, Z+7	; 0x07
    1250:	0e 94 f1 11 	call	0x23e2	; 0x23e2 <memcpy>
    1254:	08 95       	ret

00001256 <prvUnlockQueue>:
    1256:	ef 92       	push	r14
    1258:	ff 92       	push	r15
    125a:	0f 93       	push	r16
    125c:	1f 93       	push	r17
    125e:	cf 93       	push	r28
    1260:	8c 01       	movw	r16, r24
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	0f 92       	push	r0
    1268:	fc 01       	movw	r30, r24
    126a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    126c:	1c 16       	cp	r1, r28
    126e:	ac f4       	brge	.+42     	; 0x129a <prvUnlockQueue+0x44>
    1270:	81 89       	ldd	r24, Z+17	; 0x11
    1272:	81 11       	cpse	r24, r1
    1274:	06 c0       	rjmp	.+12     	; 0x1282 <prvUnlockQueue+0x2c>
    1276:	11 c0       	rjmp	.+34     	; 0x129a <prvUnlockQueue+0x44>
    1278:	f8 01       	movw	r30, r16
    127a:	81 89       	ldd	r24, Z+17	; 0x11
    127c:	81 11       	cpse	r24, r1
    127e:	05 c0       	rjmp	.+10     	; 0x128a <prvUnlockQueue+0x34>
    1280:	0c c0       	rjmp	.+24     	; 0x129a <prvUnlockQueue+0x44>
    1282:	78 01       	movw	r14, r16
    1284:	f1 e1       	ldi	r31, 0x11	; 17
    1286:	ef 0e       	add	r14, r31
    1288:	f1 1c       	adc	r15, r1
    128a:	c7 01       	movw	r24, r14
    128c:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    1290:	81 11       	cpse	r24, r1
    1292:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <vTaskMissedYield>
    1296:	c1 50       	subi	r28, 0x01	; 1
    1298:	79 f7       	brne	.-34     	; 0x1278 <prvUnlockQueue+0x22>
    129a:	8f ef       	ldi	r24, 0xFF	; 255
    129c:	f8 01       	movw	r30, r16
    129e:	86 8f       	std	Z+30, r24	; 0x1e
    12a0:	0f 90       	pop	r0
    12a2:	0f be       	out	0x3f, r0	; 63
    12a4:	0f b6       	in	r0, 0x3f	; 63
    12a6:	f8 94       	cli
    12a8:	0f 92       	push	r0
    12aa:	c5 8d       	ldd	r28, Z+29	; 0x1d
    12ac:	1c 16       	cp	r1, r28
    12ae:	ac f4       	brge	.+42     	; 0x12da <prvUnlockQueue+0x84>
    12b0:	80 85       	ldd	r24, Z+8	; 0x08
    12b2:	81 11       	cpse	r24, r1
    12b4:	06 c0       	rjmp	.+12     	; 0x12c2 <prvUnlockQueue+0x6c>
    12b6:	11 c0       	rjmp	.+34     	; 0x12da <prvUnlockQueue+0x84>
    12b8:	f8 01       	movw	r30, r16
    12ba:	80 85       	ldd	r24, Z+8	; 0x08
    12bc:	81 11       	cpse	r24, r1
    12be:	05 c0       	rjmp	.+10     	; 0x12ca <prvUnlockQueue+0x74>
    12c0:	0c c0       	rjmp	.+24     	; 0x12da <prvUnlockQueue+0x84>
    12c2:	78 01       	movw	r14, r16
    12c4:	f8 e0       	ldi	r31, 0x08	; 8
    12c6:	ef 0e       	add	r14, r31
    12c8:	f1 1c       	adc	r15, r1
    12ca:	c7 01       	movw	r24, r14
    12cc:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    12d0:	81 11       	cpse	r24, r1
    12d2:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <vTaskMissedYield>
    12d6:	c1 50       	subi	r28, 0x01	; 1
    12d8:	79 f7       	brne	.-34     	; 0x12b8 <prvUnlockQueue+0x62>
    12da:	8f ef       	ldi	r24, 0xFF	; 255
    12dc:	f8 01       	movw	r30, r16
    12de:	85 8f       	std	Z+29, r24	; 0x1d
    12e0:	0f 90       	pop	r0
    12e2:	0f be       	out	0x3f, r0	; 63
    12e4:	cf 91       	pop	r28
    12e6:	1f 91       	pop	r17
    12e8:	0f 91       	pop	r16
    12ea:	ff 90       	pop	r15
    12ec:	ef 90       	pop	r14
    12ee:	08 95       	ret

000012f0 <xQueueGenericReset>:
    12f0:	cf 93       	push	r28
    12f2:	df 93       	push	r29
    12f4:	ec 01       	movw	r28, r24
    12f6:	0f b6       	in	r0, 0x3f	; 63
    12f8:	f8 94       	cli
    12fa:	0f 92       	push	r0
    12fc:	48 81       	ld	r20, Y
    12fe:	59 81       	ldd	r21, Y+1	; 0x01
    1300:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1302:	30 e0       	ldi	r19, 0x00	; 0
    1304:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1306:	72 9f       	mul	r23, r18
    1308:	c0 01       	movw	r24, r0
    130a:	73 9f       	mul	r23, r19
    130c:	90 0d       	add	r25, r0
    130e:	11 24       	eor	r1, r1
    1310:	fa 01       	movw	r30, r20
    1312:	e8 0f       	add	r30, r24
    1314:	f9 1f       	adc	r31, r25
    1316:	fb 83       	std	Y+3, r31	; 0x03
    1318:	ea 83       	std	Y+2, r30	; 0x02
    131a:	1a 8e       	std	Y+26, r1	; 0x1a
    131c:	5d 83       	std	Y+5, r21	; 0x05
    131e:	4c 83       	std	Y+4, r20	; 0x04
    1320:	82 1b       	sub	r24, r18
    1322:	93 0b       	sbc	r25, r19
    1324:	84 0f       	add	r24, r20
    1326:	95 1f       	adc	r25, r21
    1328:	9f 83       	std	Y+7, r25	; 0x07
    132a:	8e 83       	std	Y+6, r24	; 0x06
    132c:	8f ef       	ldi	r24, 0xFF	; 255
    132e:	8d 8f       	std	Y+29, r24	; 0x1d
    1330:	8e 8f       	std	Y+30, r24	; 0x1e
    1332:	61 11       	cpse	r22, r1
    1334:	0c c0       	rjmp	.+24     	; 0x134e <xQueueGenericReset+0x5e>
    1336:	88 85       	ldd	r24, Y+8	; 0x08
    1338:	88 23       	and	r24, r24
    133a:	89 f0       	breq	.+34     	; 0x135e <xQueueGenericReset+0x6e>
    133c:	ce 01       	movw	r24, r28
    133e:	08 96       	adiw	r24, 0x08	; 8
    1340:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    1344:	88 23       	and	r24, r24
    1346:	59 f0       	breq	.+22     	; 0x135e <xQueueGenericReset+0x6e>
    1348:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    134c:	08 c0       	rjmp	.+16     	; 0x135e <xQueueGenericReset+0x6e>
    134e:	ce 01       	movw	r24, r28
    1350:	08 96       	adiw	r24, 0x08	; 8
    1352:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    1356:	ce 01       	movw	r24, r28
    1358:	41 96       	adiw	r24, 0x11	; 17
    135a:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    135e:	0f 90       	pop	r0
    1360:	0f be       	out	0x3f, r0	; 63
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	08 95       	ret

0000136a <xQueueGenericCreate>:
    136a:	ff 92       	push	r15
    136c:	0f 93       	push	r16
    136e:	1f 93       	push	r17
    1370:	cf 93       	push	r28
    1372:	df 93       	push	r29
    1374:	08 2f       	mov	r16, r24
    1376:	16 2f       	mov	r17, r22
    1378:	f4 2e       	mov	r15, r20
    137a:	66 23       	and	r22, r22
    137c:	c9 f0       	breq	.+50     	; 0x13b0 <xQueueGenericCreate+0x46>
    137e:	86 9f       	mul	r24, r22
    1380:	c0 01       	movw	r24, r0
    1382:	11 24       	eor	r1, r1
    1384:	81 96       	adiw	r24, 0x21	; 33
    1386:	0e 94 b3 06 	call	0xd66	; 0xd66 <pvPortMalloc>
    138a:	ec 01       	movw	r28, r24
    138c:	00 97       	sbiw	r24, 0x00	; 0
    138e:	49 f4       	brne	.+18     	; 0x13a2 <xQueueGenericCreate+0x38>
    1390:	16 c0       	rjmp	.+44     	; 0x13be <xQueueGenericCreate+0x54>
    1392:	0b 8f       	std	Y+27, r16	; 0x1b
    1394:	1c 8f       	std	Y+28, r17	; 0x1c
    1396:	61 e0       	ldi	r22, 0x01	; 1
    1398:	ce 01       	movw	r24, r28
    139a:	0e 94 78 09 	call	0x12f0	; 0x12f0 <xQueueGenericReset>
    139e:	f8 a2       	std	Y+32, r15	; 0x20
    13a0:	0e c0       	rjmp	.+28     	; 0x13be <xQueueGenericCreate+0x54>
    13a2:	81 96       	adiw	r24, 0x21	; 33
    13a4:	99 83       	std	Y+1, r25	; 0x01
    13a6:	88 83       	st	Y, r24
    13a8:	f4 cf       	rjmp	.-24     	; 0x1392 <xQueueGenericCreate+0x28>
    13aa:	d9 83       	std	Y+1, r29	; 0x01
    13ac:	c8 83       	st	Y, r28
    13ae:	f1 cf       	rjmp	.-30     	; 0x1392 <xQueueGenericCreate+0x28>
    13b0:	81 e2       	ldi	r24, 0x21	; 33
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	0e 94 b3 06 	call	0xd66	; 0xd66 <pvPortMalloc>
    13b8:	ec 01       	movw	r28, r24
    13ba:	89 2b       	or	r24, r25
    13bc:	b1 f7       	brne	.-20     	; 0x13aa <xQueueGenericCreate+0x40>
    13be:	ce 01       	movw	r24, r28
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	ff 90       	pop	r15
    13ca:	08 95       	ret

000013cc <xQueueGenericSend>:
    13cc:	9f 92       	push	r9
    13ce:	af 92       	push	r10
    13d0:	bf 92       	push	r11
    13d2:	cf 92       	push	r12
    13d4:	df 92       	push	r13
    13d6:	ef 92       	push	r14
    13d8:	ff 92       	push	r15
    13da:	0f 93       	push	r16
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	00 d0       	rcall	.+0      	; 0x13e4 <xQueueGenericSend+0x18>
    13e4:	00 d0       	rcall	.+0      	; 0x13e6 <xQueueGenericSend+0x1a>
    13e6:	1f 92       	push	r1
    13e8:	cd b7       	in	r28, 0x3d	; 61
    13ea:	de b7       	in	r29, 0x3e	; 62
    13ec:	8c 01       	movw	r16, r24
    13ee:	6b 01       	movw	r12, r22
    13f0:	5d 83       	std	Y+5, r21	; 0x05
    13f2:	4c 83       	std	Y+4, r20	; 0x04
    13f4:	a2 2e       	mov	r10, r18
    13f6:	b1 2c       	mov	r11, r1
    13f8:	99 24       	eor	r9, r9
    13fa:	93 94       	inc	r9
    13fc:	7c 01       	movw	r14, r24
    13fe:	88 e0       	ldi	r24, 0x08	; 8
    1400:	e8 0e       	add	r14, r24
    1402:	f1 1c       	adc	r15, r1
    1404:	0f b6       	in	r0, 0x3f	; 63
    1406:	f8 94       	cli
    1408:	0f 92       	push	r0
    140a:	f8 01       	movw	r30, r16
    140c:	92 8d       	ldd	r25, Z+26	; 0x1a
    140e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1410:	98 17       	cp	r25, r24
    1412:	18 f0       	brcs	.+6      	; 0x141a <xQueueGenericSend+0x4e>
    1414:	f2 e0       	ldi	r31, 0x02	; 2
    1416:	af 12       	cpse	r10, r31
    1418:	19 c0       	rjmp	.+50     	; 0x144c <xQueueGenericSend+0x80>
    141a:	4a 2d       	mov	r20, r10
    141c:	b6 01       	movw	r22, r12
    141e:	c8 01       	movw	r24, r16
    1420:	0e 94 b2 08 	call	0x1164	; 0x1164 <prvCopyDataToQueue>
    1424:	f8 01       	movw	r30, r16
    1426:	91 89       	ldd	r25, Z+17	; 0x11
    1428:	99 23       	and	r25, r25
    142a:	49 f0       	breq	.+18     	; 0x143e <xQueueGenericSend+0x72>
    142c:	c8 01       	movw	r24, r16
    142e:	41 96       	adiw	r24, 0x11	; 17
    1430:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    1434:	88 23       	and	r24, r24
    1436:	31 f0       	breq	.+12     	; 0x1444 <xQueueGenericSend+0x78>
    1438:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    143c:	03 c0       	rjmp	.+6      	; 0x1444 <xQueueGenericSend+0x78>
    143e:	81 11       	cpse	r24, r1
    1440:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    1444:	0f 90       	pop	r0
    1446:	0f be       	out	0x3f, r0	; 63
    1448:	81 e0       	ldi	r24, 0x01	; 1
    144a:	50 c0       	rjmp	.+160    	; 0x14ec <xQueueGenericSend+0x120>
    144c:	8c 81       	ldd	r24, Y+4	; 0x04
    144e:	9d 81       	ldd	r25, Y+5	; 0x05
    1450:	89 2b       	or	r24, r25
    1452:	21 f4       	brne	.+8      	; 0x145c <xQueueGenericSend+0x90>
    1454:	0f 90       	pop	r0
    1456:	0f be       	out	0x3f, r0	; 63
    1458:	80 e0       	ldi	r24, 0x00	; 0
    145a:	48 c0       	rjmp	.+144    	; 0x14ec <xQueueGenericSend+0x120>
    145c:	b1 10       	cpse	r11, r1
    145e:	05 c0       	rjmp	.+10     	; 0x146a <xQueueGenericSend+0x9e>
    1460:	ce 01       	movw	r24, r28
    1462:	01 96       	adiw	r24, 0x01	; 1
    1464:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <vTaskSetTimeOutState>
    1468:	b9 2c       	mov	r11, r9
    146a:	0f 90       	pop	r0
    146c:	0f be       	out	0x3f, r0	; 63
    146e:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vTaskSuspendAll>
    1472:	0f b6       	in	r0, 0x3f	; 63
    1474:	f8 94       	cli
    1476:	0f 92       	push	r0
    1478:	f8 01       	movw	r30, r16
    147a:	85 8d       	ldd	r24, Z+29	; 0x1d
    147c:	8f 3f       	cpi	r24, 0xFF	; 255
    147e:	09 f4       	brne	.+2      	; 0x1482 <xQueueGenericSend+0xb6>
    1480:	15 8e       	std	Z+29, r1	; 0x1d
    1482:	f8 01       	movw	r30, r16
    1484:	86 8d       	ldd	r24, Z+30	; 0x1e
    1486:	8f 3f       	cpi	r24, 0xFF	; 255
    1488:	09 f4       	brne	.+2      	; 0x148c <xQueueGenericSend+0xc0>
    148a:	16 8e       	std	Z+30, r1	; 0x1e
    148c:	0f 90       	pop	r0
    148e:	0f be       	out	0x3f, r0	; 63
    1490:	be 01       	movw	r22, r28
    1492:	6c 5f       	subi	r22, 0xFC	; 252
    1494:	7f 4f       	sbci	r23, 0xFF	; 255
    1496:	ce 01       	movw	r24, r28
    1498:	01 96       	adiw	r24, 0x01	; 1
    149a:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <xTaskCheckForTimeOut>
    149e:	81 11       	cpse	r24, r1
    14a0:	1f c0       	rjmp	.+62     	; 0x14e0 <xQueueGenericSend+0x114>
    14a2:	0f b6       	in	r0, 0x3f	; 63
    14a4:	f8 94       	cli
    14a6:	0f 92       	push	r0
    14a8:	f8 01       	movw	r30, r16
    14aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    14ac:	0f 90       	pop	r0
    14ae:	0f be       	out	0x3f, r0	; 63
    14b0:	83 8d       	ldd	r24, Z+27	; 0x1b
    14b2:	98 13       	cpse	r25, r24
    14b4:	0f c0       	rjmp	.+30     	; 0x14d4 <xQueueGenericSend+0x108>
    14b6:	6c 81       	ldd	r22, Y+4	; 0x04
    14b8:	7d 81       	ldd	r23, Y+5	; 0x05
    14ba:	c7 01       	movw	r24, r14
    14bc:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskPlaceOnEventList>
    14c0:	c8 01       	movw	r24, r16
    14c2:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
    14c6:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    14ca:	81 11       	cpse	r24, r1
    14cc:	9b cf       	rjmp	.-202    	; 0x1404 <xQueueGenericSend+0x38>
    14ce:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    14d2:	98 cf       	rjmp	.-208    	; 0x1404 <xQueueGenericSend+0x38>
    14d4:	c8 01       	movw	r24, r16
    14d6:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
    14da:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    14de:	92 cf       	rjmp	.-220    	; 0x1404 <xQueueGenericSend+0x38>
    14e0:	c8 01       	movw	r24, r16
    14e2:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
    14e6:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	0f 90       	pop	r0
    14ee:	0f 90       	pop	r0
    14f0:	0f 90       	pop	r0
    14f2:	0f 90       	pop	r0
    14f4:	0f 90       	pop	r0
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	1f 91       	pop	r17
    14fc:	0f 91       	pop	r16
    14fe:	ff 90       	pop	r15
    1500:	ef 90       	pop	r14
    1502:	df 90       	pop	r13
    1504:	cf 90       	pop	r12
    1506:	bf 90       	pop	r11
    1508:	af 90       	pop	r10
    150a:	9f 90       	pop	r9
    150c:	08 95       	ret

0000150e <xQueueCreateMutex>:
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	48 2f       	mov	r20, r24
    1514:	60 e0       	ldi	r22, 0x00	; 0
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	0e 94 b5 09 	call	0x136a	; 0x136a <xQueueGenericCreate>
    151c:	ec 01       	movw	r28, r24
    151e:	00 97       	sbiw	r24, 0x00	; 0
    1520:	61 f0       	breq	.+24     	; 0x153a <xQueueCreateMutex+0x2c>
    1522:	1b 82       	std	Y+3, r1	; 0x03
    1524:	1a 82       	std	Y+2, r1	; 0x02
    1526:	19 82       	std	Y+1, r1	; 0x01
    1528:	18 82       	st	Y, r1
    152a:	1e 82       	std	Y+6, r1	; 0x06
    152c:	20 e0       	ldi	r18, 0x00	; 0
    152e:	40 e0       	ldi	r20, 0x00	; 0
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	60 e0       	ldi	r22, 0x00	; 0
    1534:	70 e0       	ldi	r23, 0x00	; 0
    1536:	0e 94 e6 09 	call	0x13cc	; 0x13cc <xQueueGenericSend>
    153a:	ce 01       	movw	r24, r28
    153c:	df 91       	pop	r29
    153e:	cf 91       	pop	r28
    1540:	08 95       	ret

00001542 <xQueueGenericSendFromISR>:
    1542:	ef 92       	push	r14
    1544:	ff 92       	push	r15
    1546:	0f 93       	push	r16
    1548:	1f 93       	push	r17
    154a:	cf 93       	push	r28
    154c:	df 93       	push	r29
    154e:	8a 01       	movw	r16, r20
    1550:	fc 01       	movw	r30, r24
    1552:	52 8d       	ldd	r21, Z+26	; 0x1a
    1554:	33 8d       	ldd	r19, Z+27	; 0x1b
    1556:	53 17       	cp	r21, r19
    1558:	10 f0       	brcs	.+4      	; 0x155e <xQueueGenericSendFromISR+0x1c>
    155a:	22 30       	cpi	r18, 0x02	; 2
    155c:	f1 f4       	brne	.+60     	; 0x159a <xQueueGenericSendFromISR+0x58>
    155e:	42 2f       	mov	r20, r18
    1560:	78 01       	movw	r14, r16
    1562:	ec 01       	movw	r28, r24
    1564:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1566:	0e 94 b2 08 	call	0x1164	; 0x1164 <prvCopyDataToQueue>
    156a:	1f 3f       	cpi	r17, 0xFF	; 255
    156c:	81 f4       	brne	.+32     	; 0x158e <xQueueGenericSendFromISR+0x4c>
    156e:	89 89       	ldd	r24, Y+17	; 0x11
    1570:	88 23       	and	r24, r24
    1572:	a9 f0       	breq	.+42     	; 0x159e <xQueueGenericSendFromISR+0x5c>
    1574:	ce 01       	movw	r24, r28
    1576:	41 96       	adiw	r24, 0x11	; 17
    1578:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    157c:	88 23       	and	r24, r24
    157e:	89 f0       	breq	.+34     	; 0x15a2 <xQueueGenericSendFromISR+0x60>
    1580:	e1 14       	cp	r14, r1
    1582:	f1 04       	cpc	r15, r1
    1584:	81 f0       	breq	.+32     	; 0x15a6 <xQueueGenericSendFromISR+0x64>
    1586:	81 e0       	ldi	r24, 0x01	; 1
    1588:	f7 01       	movw	r30, r14
    158a:	80 83       	st	Z, r24
    158c:	0d c0       	rjmp	.+26     	; 0x15a8 <xQueueGenericSendFromISR+0x66>
    158e:	ff 24       	eor	r15, r15
    1590:	f3 94       	inc	r15
    1592:	f1 0e       	add	r15, r17
    1594:	fe 8e       	std	Y+30, r15	; 0x1e
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	07 c0       	rjmp	.+14     	; 0x15a8 <xQueueGenericSendFromISR+0x66>
    159a:	80 e0       	ldi	r24, 0x00	; 0
    159c:	05 c0       	rjmp	.+10     	; 0x15a8 <xQueueGenericSendFromISR+0x66>
    159e:	81 e0       	ldi	r24, 0x01	; 1
    15a0:	03 c0       	rjmp	.+6      	; 0x15a8 <xQueueGenericSendFromISR+0x66>
    15a2:	81 e0       	ldi	r24, 0x01	; 1
    15a4:	01 c0       	rjmp	.+2      	; 0x15a8 <xQueueGenericSendFromISR+0x66>
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	df 91       	pop	r29
    15aa:	cf 91       	pop	r28
    15ac:	1f 91       	pop	r17
    15ae:	0f 91       	pop	r16
    15b0:	ff 90       	pop	r15
    15b2:	ef 90       	pop	r14
    15b4:	08 95       	ret

000015b6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    15b6:	8f 92       	push	r8
    15b8:	9f 92       	push	r9
    15ba:	af 92       	push	r10
    15bc:	bf 92       	push	r11
    15be:	cf 92       	push	r12
    15c0:	df 92       	push	r13
    15c2:	ef 92       	push	r14
    15c4:	ff 92       	push	r15
    15c6:	0f 93       	push	r16
    15c8:	1f 93       	push	r17
    15ca:	cf 93       	push	r28
    15cc:	df 93       	push	r29
    15ce:	00 d0       	rcall	.+0      	; 0x15d0 <xQueueGenericReceive+0x1a>
    15d0:	00 d0       	rcall	.+0      	; 0x15d2 <xQueueGenericReceive+0x1c>
    15d2:	1f 92       	push	r1
    15d4:	cd b7       	in	r28, 0x3d	; 61
    15d6:	de b7       	in	r29, 0x3e	; 62
    15d8:	8c 01       	movw	r16, r24
    15da:	5b 01       	movw	r10, r22
    15dc:	5d 83       	std	Y+5, r21	; 0x05
    15de:	4c 83       	std	Y+4, r20	; 0x04
    15e0:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    15e2:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    15e4:	99 24       	eor	r9, r9
    15e6:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15e8:	6c 01       	movw	r12, r24
    15ea:	81 e1       	ldi	r24, 0x11	; 17
    15ec:	c8 0e       	add	r12, r24
    15ee:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15f6:	f8 01       	movw	r30, r16
    15f8:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15fa:	ff 20       	and	r15, r15
    15fc:	91 f1       	breq	.+100    	; 0x1662 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    15fe:	c6 80       	ldd	r12, Z+6	; 0x06
    1600:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1602:	b5 01       	movw	r22, r10
    1604:	c8 01       	movw	r24, r16
    1606:	0e 94 11 09 	call	0x1222	; 0x1222 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    160a:	81 10       	cpse	r8, r1
    160c:	19 c0       	rjmp	.+50     	; 0x1640 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    160e:	fa 94       	dec	r15
    1610:	f8 01       	movw	r30, r16
    1612:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1614:	80 81       	ld	r24, Z
    1616:	91 81       	ldd	r25, Z+1	; 0x01
    1618:	89 2b       	or	r24, r25
    161a:	29 f4       	brne	.+10     	; 0x1626 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    161c:	0e 94 9c 10 	call	0x2138	; 0x2138 <pvTaskIncrementMutexHeldCount>
    1620:	f8 01       	movw	r30, r16
    1622:	93 83       	std	Z+3, r25	; 0x03
    1624:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1626:	f8 01       	movw	r30, r16
    1628:	80 85       	ldd	r24, Z+8	; 0x08
    162a:	88 23       	and	r24, r24
    162c:	b1 f0       	breq	.+44     	; 0x165a <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    162e:	c8 01       	movw	r24, r16
    1630:	08 96       	adiw	r24, 0x08	; 8
    1632:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    1636:	88 23       	and	r24, r24
    1638:	81 f0       	breq	.+32     	; 0x165a <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
    163a:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    163e:	0d c0       	rjmp	.+26     	; 0x165a <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1640:	f8 01       	movw	r30, r16
    1642:	d7 82       	std	Z+7, r13	; 0x07
    1644:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1646:	81 89       	ldd	r24, Z+17	; 0x11
    1648:	88 23       	and	r24, r24
    164a:	39 f0       	breq	.+14     	; 0x165a <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    164c:	c8 01       	movw	r24, r16
    164e:	41 96       	adiw	r24, 0x11	; 17
    1650:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <xTaskRemoveFromEventList>
    1654:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1656:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    165a:	0f 90       	pop	r0
    165c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	64 c0       	rjmp	.+200    	; 0x172a <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1662:	8c 81       	ldd	r24, Y+4	; 0x04
    1664:	9d 81       	ldd	r25, Y+5	; 0x05
    1666:	89 2b       	or	r24, r25
    1668:	21 f4       	brne	.+8      	; 0x1672 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    166a:	0f 90       	pop	r0
    166c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    166e:	80 e0       	ldi	r24, 0x00	; 0
    1670:	5c c0       	rjmp	.+184    	; 0x172a <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    1672:	e1 10       	cpse	r14, r1
    1674:	05 c0       	rjmp	.+10     	; 0x1680 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1676:	ce 01       	movw	r24, r28
    1678:	01 96       	adiw	r24, 0x01	; 1
    167a:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    167e:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1680:	0f 90       	pop	r0
    1682:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1684:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1688:	0f b6       	in	r0, 0x3f	; 63
    168a:	f8 94       	cli
    168c:	0f 92       	push	r0
    168e:	f8 01       	movw	r30, r16
    1690:	85 8d       	ldd	r24, Z+29	; 0x1d
    1692:	8f 3f       	cpi	r24, 0xFF	; 255
    1694:	09 f4       	brne	.+2      	; 0x1698 <xQueueGenericReceive+0xe2>
    1696:	15 8e       	std	Z+29, r1	; 0x1d
    1698:	f8 01       	movw	r30, r16
    169a:	86 8d       	ldd	r24, Z+30	; 0x1e
    169c:	8f 3f       	cpi	r24, 0xFF	; 255
    169e:	09 f4       	brne	.+2      	; 0x16a2 <xQueueGenericReceive+0xec>
    16a0:	16 8e       	std	Z+30, r1	; 0x1e
    16a2:	0f 90       	pop	r0
    16a4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16a6:	be 01       	movw	r22, r28
    16a8:	6c 5f       	subi	r22, 0xFC	; 252
    16aa:	7f 4f       	sbci	r23, 0xFF	; 255
    16ac:	ce 01       	movw	r24, r28
    16ae:	01 96       	adiw	r24, 0x01	; 1
    16b0:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <xTaskCheckForTimeOut>
    16b4:	81 11       	cpse	r24, r1
    16b6:	2b c0       	rjmp	.+86     	; 0x170e <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    16b8:	0f b6       	in	r0, 0x3f	; 63
    16ba:	f8 94       	cli
    16bc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    16be:	f8 01       	movw	r30, r16
    16c0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    16c2:	0f 90       	pop	r0
    16c4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16c6:	81 11       	cpse	r24, r1
    16c8:	1c c0       	rjmp	.+56     	; 0x1702 <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    16ca:	80 81       	ld	r24, Z
    16cc:	91 81       	ldd	r25, Z+1	; 0x01
    16ce:	89 2b       	or	r24, r25
    16d0:	49 f4       	brne	.+18     	; 0x16e4 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
    16d2:	0f b6       	in	r0, 0x3f	; 63
    16d4:	f8 94       	cli
    16d6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    16d8:	82 81       	ldd	r24, Z+2	; 0x02
    16da:	93 81       	ldd	r25, Z+3	; 0x03
    16dc:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    16e0:	0f 90       	pop	r0
    16e2:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16e4:	6c 81       	ldd	r22, Y+4	; 0x04
    16e6:	7d 81       	ldd	r23, Y+5	; 0x05
    16e8:	c6 01       	movw	r24, r12
    16ea:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    16ee:	c8 01       	movw	r24, r16
    16f0:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    16f4:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    16f8:	81 11       	cpse	r24, r1
    16fa:	7a cf       	rjmp	.-268    	; 0x15f0 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    16fc:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    1700:	77 cf       	rjmp	.-274    	; 0x15f0 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1702:	c8 01       	movw	r24, r16
    1704:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1708:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    170c:	71 cf       	rjmp	.-286    	; 0x15f0 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    170e:	c8 01       	movw	r24, r16
    1710:	0e 94 2b 09 	call	0x1256	; 0x1256 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1714:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1718:	0f b6       	in	r0, 0x3f	; 63
    171a:	f8 94       	cli
    171c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    171e:	f8 01       	movw	r30, r16
    1720:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1722:	0f 90       	pop	r0
    1724:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1726:	81 11       	cpse	r24, r1
    1728:	63 cf       	rjmp	.-314    	; 0x15f0 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	0f 90       	pop	r0
    1734:	df 91       	pop	r29
    1736:	cf 91       	pop	r28
    1738:	1f 91       	pop	r17
    173a:	0f 91       	pop	r16
    173c:	ff 90       	pop	r15
    173e:	ef 90       	pop	r14
    1740:	df 90       	pop	r13
    1742:	cf 90       	pop	r12
    1744:	bf 90       	pop	r11
    1746:	af 90       	pop	r10
    1748:	9f 90       	pop	r9
    174a:	8f 90       	pop	r8
    174c:	08 95       	ret

0000174e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    174e:	e0 91 c0 05 	lds	r30, 0x05C0	; 0x8005c0 <pxDelayedTaskList>
    1752:	f0 91 c1 05 	lds	r31, 0x05C1	; 0x8005c1 <pxDelayedTaskList+0x1>
    1756:	80 81       	ld	r24, Z
    1758:	81 11       	cpse	r24, r1
    175a:	07 c0       	rjmp	.+14     	; 0x176a <prvResetNextTaskUnblockTime+0x1c>
    175c:	8f ef       	ldi	r24, 0xFF	; 255
    175e:	9f ef       	ldi	r25, 0xFF	; 255
    1760:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1764:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <xNextTaskUnblockTime>
    1768:	08 95       	ret
    176a:	e0 91 c0 05 	lds	r30, 0x05C0	; 0x8005c0 <pxDelayedTaskList>
    176e:	f0 91 c1 05 	lds	r31, 0x05C1	; 0x8005c1 <pxDelayedTaskList+0x1>
    1772:	05 80       	ldd	r0, Z+5	; 0x05
    1774:	f6 81       	ldd	r31, Z+6	; 0x06
    1776:	e0 2d       	mov	r30, r0
    1778:	06 80       	ldd	r0, Z+6	; 0x06
    177a:	f7 81       	ldd	r31, Z+7	; 0x07
    177c:	e0 2d       	mov	r30, r0
    177e:	82 81       	ldd	r24, Z+2	; 0x02
    1780:	93 81       	ldd	r25, Z+3	; 0x03
    1782:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1786:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <xNextTaskUnblockTime>
    178a:	08 95       	ret

0000178c <prvAddCurrentTaskToDelayedList>:
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	cf 93       	push	r28
    1792:	df 93       	push	r29
    1794:	ec 01       	movw	r28, r24
    1796:	00 91 a8 05 	lds	r16, 0x05A8	; 0x8005a8 <xTickCount>
    179a:	10 91 a9 05 	lds	r17, 0x05A9	; 0x8005a9 <xTickCount+0x1>
    179e:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    17a2:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    17a6:	02 96       	adiw	r24, 0x02	; 2
    17a8:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    17ac:	c0 0f       	add	r28, r16
    17ae:	d1 1f       	adc	r29, r17
    17b0:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    17b4:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    17b8:	d3 83       	std	Z+3, r29	; 0x03
    17ba:	c2 83       	std	Z+2, r28	; 0x02
    17bc:	c0 17       	cp	r28, r16
    17be:	d1 07       	cpc	r29, r17
    17c0:	68 f4       	brcc	.+26     	; 0x17dc <prvAddCurrentTaskToDelayedList+0x50>
    17c2:	60 91 f8 05 	lds	r22, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    17c6:	70 91 f9 05 	lds	r23, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    17ca:	80 91 be 05 	lds	r24, 0x05BE	; 0x8005be <pxOverflowDelayedTaskList>
    17ce:	90 91 bf 05 	lds	r25, 0x05BF	; 0x8005bf <pxOverflowDelayedTaskList+0x1>
    17d2:	6e 5f       	subi	r22, 0xFE	; 254
    17d4:	7f 4f       	sbci	r23, 0xFF	; 255
    17d6:	0e 94 fe 04 	call	0x9fc	; 0x9fc <vListInsert>
    17da:	17 c0       	rjmp	.+46     	; 0x180a <prvAddCurrentTaskToDelayedList+0x7e>
    17dc:	60 91 f8 05 	lds	r22, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    17e0:	70 91 f9 05 	lds	r23, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    17e4:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <pxDelayedTaskList>
    17e8:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <pxDelayedTaskList+0x1>
    17ec:	6e 5f       	subi	r22, 0xFE	; 254
    17ee:	7f 4f       	sbci	r23, 0xFF	; 255
    17f0:	0e 94 fe 04 	call	0x9fc	; 0x9fc <vListInsert>
    17f4:	80 91 a0 05 	lds	r24, 0x05A0	; 0x8005a0 <xNextTaskUnblockTime>
    17f8:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    17fc:	c8 17       	cp	r28, r24
    17fe:	d9 07       	cpc	r29, r25
    1800:	20 f4       	brcc	.+8      	; 0x180a <prvAddCurrentTaskToDelayedList+0x7e>
    1802:	d0 93 a1 05 	sts	0x05A1, r29	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1806:	c0 93 a0 05 	sts	0x05A0, r28	; 0x8005a0 <xNextTaskUnblockTime>
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	1f 91       	pop	r17
    1810:	0f 91       	pop	r16
    1812:	08 95       	ret

00001814 <xTaskCreate>:
    1814:	4f 92       	push	r4
    1816:	5f 92       	push	r5
    1818:	6f 92       	push	r6
    181a:	7f 92       	push	r7
    181c:	8f 92       	push	r8
    181e:	9f 92       	push	r9
    1820:	af 92       	push	r10
    1822:	bf 92       	push	r11
    1824:	cf 92       	push	r12
    1826:	df 92       	push	r13
    1828:	ef 92       	push	r14
    182a:	ff 92       	push	r15
    182c:	0f 93       	push	r16
    182e:	cf 93       	push	r28
    1830:	df 93       	push	r29
    1832:	4c 01       	movw	r8, r24
    1834:	6b 01       	movw	r12, r22
    1836:	5a 01       	movw	r10, r20
    1838:	29 01       	movw	r4, r18
    183a:	ca 01       	movw	r24, r20
    183c:	0e 94 b3 06 	call	0xd66	; 0xd66 <pvPortMalloc>
    1840:	3c 01       	movw	r6, r24
    1842:	89 2b       	or	r24, r25
    1844:	09 f4       	brne	.+2      	; 0x1848 <xTaskCreate+0x34>
    1846:	ea c0       	rjmp	.+468    	; 0x1a1c <xTaskCreate+0x208>
    1848:	8c e2       	ldi	r24, 0x2C	; 44
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	0e 94 b3 06 	call	0xd66	; 0xd66 <pvPortMalloc>
    1850:	ec 01       	movw	r28, r24
    1852:	89 2b       	or	r24, r25
    1854:	b1 f0       	breq	.+44     	; 0x1882 <xTaskCreate+0x6e>
    1856:	78 8e       	std	Y+24, r7	; 0x18
    1858:	6f 8a       	std	Y+23, r6	; 0x17
    185a:	a5 01       	movw	r20, r10
    185c:	65 ea       	ldi	r22, 0xA5	; 165
    185e:	70 e0       	ldi	r23, 0x00	; 0
    1860:	c3 01       	movw	r24, r6
    1862:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <memset>
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	a8 1a       	sub	r10, r24
    186a:	b1 08       	sbc	r11, r1
    186c:	8f 89       	ldd	r24, Y+23	; 0x17
    186e:	98 8d       	ldd	r25, Y+24	; 0x18
    1870:	a8 0e       	add	r10, r24
    1872:	b9 1e       	adc	r11, r25
    1874:	d6 01       	movw	r26, r12
    1876:	8c 91       	ld	r24, X
    1878:	89 8f       	std	Y+25, r24	; 0x19
    187a:	8c 91       	ld	r24, X
    187c:	81 11       	cpse	r24, r1
    187e:	05 c0       	rjmp	.+10     	; 0x188a <xTaskCreate+0x76>
    1880:	18 c0       	rjmp	.+48     	; 0x18b2 <xTaskCreate+0x9e>
    1882:	c3 01       	movw	r24, r6
    1884:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <vPortFree>
    1888:	c9 c0       	rjmp	.+402    	; 0x1a1c <xTaskCreate+0x208>
    188a:	ae 01       	movw	r20, r28
    188c:	46 5e       	subi	r20, 0xE6	; 230
    188e:	5f 4f       	sbci	r21, 0xFF	; 255
    1890:	f6 01       	movw	r30, r12
    1892:	31 96       	adiw	r30, 0x01	; 1
    1894:	b8 e0       	ldi	r27, 0x08	; 8
    1896:	cb 0e       	add	r12, r27
    1898:	d1 1c       	adc	r13, r1
    189a:	cf 01       	movw	r24, r30
    189c:	21 91       	ld	r18, Z+
    189e:	da 01       	movw	r26, r20
    18a0:	2d 93       	st	X+, r18
    18a2:	ad 01       	movw	r20, r26
    18a4:	dc 01       	movw	r26, r24
    18a6:	8c 91       	ld	r24, X
    18a8:	88 23       	and	r24, r24
    18aa:	19 f0       	breq	.+6      	; 0x18b2 <xTaskCreate+0x9e>
    18ac:	ec 15       	cp	r30, r12
    18ae:	fd 05       	cpc	r31, r13
    18b0:	a1 f7       	brne	.-24     	; 0x189a <xTaskCreate+0x86>
    18b2:	18 a2       	std	Y+32, r1	; 0x20
    18b4:	04 30       	cpi	r16, 0x04	; 4
    18b6:	08 f0       	brcs	.+2      	; 0x18ba <xTaskCreate+0xa6>
    18b8:	03 e0       	ldi	r16, 0x03	; 3
    18ba:	0e 8b       	std	Y+22, r16	; 0x16
    18bc:	0b a3       	std	Y+35, r16	; 0x23
    18be:	1c a2       	std	Y+36, r1	; 0x24
    18c0:	6e 01       	movw	r12, r28
    18c2:	b2 e0       	ldi	r27, 0x02	; 2
    18c4:	cb 0e       	add	r12, r27
    18c6:	d1 1c       	adc	r13, r1
    18c8:	c6 01       	movw	r24, r12
    18ca:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <vListInitialiseItem>
    18ce:	ce 01       	movw	r24, r28
    18d0:	0c 96       	adiw	r24, 0x0c	; 12
    18d2:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <vListInitialiseItem>
    18d6:	d9 87       	std	Y+9, r29	; 0x09
    18d8:	c8 87       	std	Y+8, r28	; 0x08
    18da:	84 e0       	ldi	r24, 0x04	; 4
    18dc:	90 e0       	ldi	r25, 0x00	; 0
    18de:	80 1b       	sub	r24, r16
    18e0:	91 09       	sbc	r25, r1
    18e2:	9d 87       	std	Y+13, r25	; 0x0d
    18e4:	8c 87       	std	Y+12, r24	; 0x0c
    18e6:	db 8b       	std	Y+19, r29	; 0x13
    18e8:	ca 8b       	std	Y+18, r28	; 0x12
    18ea:	1e a2       	std	Y+38, r1	; 0x26
    18ec:	1d a2       	std	Y+37, r1	; 0x25
    18ee:	1f a2       	std	Y+39, r1	; 0x27
    18f0:	18 a6       	std	Y+40, r1	; 0x28
    18f2:	19 a6       	std	Y+41, r1	; 0x29
    18f4:	1a a6       	std	Y+42, r1	; 0x2a
    18f6:	1b a6       	std	Y+43, r1	; 0x2b
    18f8:	a2 01       	movw	r20, r4
    18fa:	b4 01       	movw	r22, r8
    18fc:	c5 01       	movw	r24, r10
    18fe:	0e 94 55 05 	call	0xaaa	; 0xaaa <pxPortInitialiseStack>
    1902:	99 83       	std	Y+1, r25	; 0x01
    1904:	88 83       	st	Y, r24
    1906:	e1 14       	cp	r14, r1
    1908:	f1 04       	cpc	r15, r1
    190a:	19 f0       	breq	.+6      	; 0x1912 <xTaskCreate+0xfe>
    190c:	f7 01       	movw	r30, r14
    190e:	d1 83       	std	Z+1, r29	; 0x01
    1910:	c0 83       	st	Z, r28
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	0f 92       	push	r0
    1918:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <uxCurrentNumberOfTasks>
    191c:	8f 5f       	subi	r24, 0xFF	; 255
    191e:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <uxCurrentNumberOfTasks>
    1922:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1926:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    192a:	89 2b       	or	r24, r25
    192c:	a9 f5       	brne	.+106    	; 0x1998 <xTaskCreate+0x184>
    192e:	d0 93 f9 05 	sts	0x05F9, r29	; 0x8005f9 <pxCurrentTCB+0x1>
    1932:	c0 93 f8 05 	sts	0x05F8, r28	; 0x8005f8 <pxCurrentTCB>
    1936:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <uxCurrentNumberOfTasks>
    193a:	81 30       	cpi	r24, 0x01	; 1
    193c:	e9 f5       	brne	.+122    	; 0x19b8 <xTaskCreate+0x1a4>
    193e:	84 ed       	ldi	r24, 0xD4	; 212
    1940:	95 e0       	ldi	r25, 0x05	; 5
    1942:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    1946:	8d ed       	ldi	r24, 0xDD	; 221
    1948:	95 e0       	ldi	r25, 0x05	; 5
    194a:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    194e:	86 ee       	ldi	r24, 0xE6	; 230
    1950:	95 e0       	ldi	r25, 0x05	; 5
    1952:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    1956:	8f ee       	ldi	r24, 0xEF	; 239
    1958:	95 e0       	ldi	r25, 0x05	; 5
    195a:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    195e:	8b ec       	ldi	r24, 0xCB	; 203
    1960:	95 e0       	ldi	r25, 0x05	; 5
    1962:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    1966:	82 ec       	ldi	r24, 0xC2	; 194
    1968:	95 e0       	ldi	r25, 0x05	; 5
    196a:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    196e:	85 eb       	ldi	r24, 0xB5	; 181
    1970:	95 e0       	ldi	r25, 0x05	; 5
    1972:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    1976:	8c ea       	ldi	r24, 0xAC	; 172
    1978:	95 e0       	ldi	r25, 0x05	; 5
    197a:	0e 94 cb 04 	call	0x996	; 0x996 <vListInitialise>
    197e:	8b ec       	ldi	r24, 0xCB	; 203
    1980:	95 e0       	ldi	r25, 0x05	; 5
    1982:	90 93 c1 05 	sts	0x05C1, r25	; 0x8005c1 <pxDelayedTaskList+0x1>
    1986:	80 93 c0 05 	sts	0x05C0, r24	; 0x8005c0 <pxDelayedTaskList>
    198a:	82 ec       	ldi	r24, 0xC2	; 194
    198c:	95 e0       	ldi	r25, 0x05	; 5
    198e:	90 93 bf 05 	sts	0x05BF, r25	; 0x8005bf <pxOverflowDelayedTaskList+0x1>
    1992:	80 93 be 05 	sts	0x05BE, r24	; 0x8005be <pxOverflowDelayedTaskList>
    1996:	10 c0       	rjmp	.+32     	; 0x19b8 <xTaskCreate+0x1a4>
    1998:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <xSchedulerRunning>
    199c:	81 11       	cpse	r24, r1
    199e:	0c c0       	rjmp	.+24     	; 0x19b8 <xTaskCreate+0x1a4>
    19a0:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    19a4:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    19a8:	96 89       	ldd	r25, Z+22	; 0x16
    19aa:	8e 89       	ldd	r24, Y+22	; 0x16
    19ac:	89 17       	cp	r24, r25
    19ae:	20 f0       	brcs	.+8      	; 0x19b8 <xTaskCreate+0x1a4>
    19b0:	d0 93 f9 05 	sts	0x05F9, r29	; 0x8005f9 <pxCurrentTCB+0x1>
    19b4:	c0 93 f8 05 	sts	0x05F8, r28	; 0x8005f8 <pxCurrentTCB>
    19b8:	80 91 a2 05 	lds	r24, 0x05A2	; 0x8005a2 <uxTaskNumber>
    19bc:	8f 5f       	subi	r24, 0xFF	; 255
    19be:	80 93 a2 05 	sts	0x05A2, r24	; 0x8005a2 <uxTaskNumber>
    19c2:	89 a3       	std	Y+33, r24	; 0x21
    19c4:	8e 89       	ldd	r24, Y+22	; 0x16
    19c6:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    19ca:	98 17       	cp	r25, r24
    19cc:	10 f4       	brcc	.+4      	; 0x19d2 <xTaskCreate+0x1be>
    19ce:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <uxTopReadyPriority>
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	9c 01       	movw	r18, r24
    19d6:	22 0f       	add	r18, r18
    19d8:	33 1f       	adc	r19, r19
    19da:	22 0f       	add	r18, r18
    19dc:	33 1f       	adc	r19, r19
    19de:	22 0f       	add	r18, r18
    19e0:	33 1f       	adc	r19, r19
    19e2:	82 0f       	add	r24, r18
    19e4:	93 1f       	adc	r25, r19
    19e6:	b6 01       	movw	r22, r12
    19e8:	8c 52       	subi	r24, 0x2C	; 44
    19ea:	9a 4f       	sbci	r25, 0xFA	; 250
    19ec:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <xSchedulerRunning>
    19f8:	88 23       	and	r24, r24
    19fa:	61 f0       	breq	.+24     	; 0x1a14 <xTaskCreate+0x200>
    19fc:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1a00:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1a04:	96 89       	ldd	r25, Z+22	; 0x16
    1a06:	8e 89       	ldd	r24, Y+22	; 0x16
    1a08:	98 17       	cp	r25, r24
    1a0a:	30 f4       	brcc	.+12     	; 0x1a18 <xTaskCreate+0x204>
    1a0c:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	05 c0       	rjmp	.+10     	; 0x1a1e <xTaskCreate+0x20a>
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	03 c0       	rjmp	.+6      	; 0x1a1e <xTaskCreate+0x20a>
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	01 c0       	rjmp	.+2      	; 0x1a1e <xTaskCreate+0x20a>
    1a1c:	8f ef       	ldi	r24, 0xFF	; 255
    1a1e:	df 91       	pop	r29
    1a20:	cf 91       	pop	r28
    1a22:	0f 91       	pop	r16
    1a24:	ff 90       	pop	r15
    1a26:	ef 90       	pop	r14
    1a28:	df 90       	pop	r13
    1a2a:	cf 90       	pop	r12
    1a2c:	bf 90       	pop	r11
    1a2e:	af 90       	pop	r10
    1a30:	9f 90       	pop	r9
    1a32:	8f 90       	pop	r8
    1a34:	7f 90       	pop	r7
    1a36:	6f 90       	pop	r6
    1a38:	5f 90       	pop	r5
    1a3a:	4f 90       	pop	r4
    1a3c:	08 95       	ret

00001a3e <vTaskStartScheduler>:
    1a3e:	ef 92       	push	r14
    1a40:	ff 92       	push	r15
    1a42:	0f 93       	push	r16
    1a44:	0f 2e       	mov	r0, r31
    1a46:	fe e9       	ldi	r31, 0x9E	; 158
    1a48:	ef 2e       	mov	r14, r31
    1a4a:	f5 e0       	ldi	r31, 0x05	; 5
    1a4c:	ff 2e       	mov	r15, r31
    1a4e:	f0 2d       	mov	r31, r0
    1a50:	00 e0       	ldi	r16, 0x00	; 0
    1a52:	20 e0       	ldi	r18, 0x00	; 0
    1a54:	30 e0       	ldi	r19, 0x00	; 0
    1a56:	45 e5       	ldi	r20, 0x55	; 85
    1a58:	50 e0       	ldi	r21, 0x00	; 0
    1a5a:	69 e2       	ldi	r22, 0x29	; 41
    1a5c:	71 e0       	ldi	r23, 0x01	; 1
    1a5e:	8d e9       	ldi	r24, 0x9D	; 157
    1a60:	9e e0       	ldi	r25, 0x0E	; 14
    1a62:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xTaskCreate>
    1a66:	81 30       	cpi	r24, 0x01	; 1
    1a68:	81 f4       	brne	.+32     	; 0x1a8a <vTaskStartScheduler+0x4c>
    1a6a:	f8 94       	cli
    1a6c:	8f ef       	ldi	r24, 0xFF	; 255
    1a6e:	9f ef       	ldi	r25, 0xFF	; 255
    1a70:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1a74:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <xNextTaskUnblockTime>
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	80 93 a6 05 	sts	0x05A6, r24	; 0x8005a6 <xSchedulerRunning>
    1a7e:	10 92 a9 05 	sts	0x05A9, r1	; 0x8005a9 <xTickCount+0x1>
    1a82:	10 92 a8 05 	sts	0x05A8, r1	; 0x8005a8 <xTickCount>
    1a86:	0e 94 c1 05 	call	0xb82	; 0xb82 <xPortStartScheduler>
    1a8a:	0f 91       	pop	r16
    1a8c:	ff 90       	pop	r15
    1a8e:	ef 90       	pop	r14
    1a90:	08 95       	ret

00001a92 <vTaskSuspendAll>:
    1a92:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <uxSchedulerSuspended>
    1a96:	8f 5f       	subi	r24, 0xFF	; 255
    1a98:	80 93 9d 05 	sts	0x059D, r24	; 0x80059d <uxSchedulerSuspended>
    1a9c:	08 95       	ret

00001a9e <xTaskIncrementTick>:
    1a9e:	cf 92       	push	r12
    1aa0:	df 92       	push	r13
    1aa2:	ef 92       	push	r14
    1aa4:	ff 92       	push	r15
    1aa6:	0f 93       	push	r16
    1aa8:	1f 93       	push	r17
    1aaa:	cf 93       	push	r28
    1aac:	df 93       	push	r29
    1aae:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <uxSchedulerSuspended>
    1ab2:	81 11       	cpse	r24, r1
    1ab4:	99 c0       	rjmp	.+306    	; 0x1be8 <xTaskIncrementTick+0x14a>
    1ab6:	e0 90 a8 05 	lds	r14, 0x05A8	; 0x8005a8 <xTickCount>
    1aba:	f0 90 a9 05 	lds	r15, 0x05A9	; 0x8005a9 <xTickCount+0x1>
    1abe:	8f ef       	ldi	r24, 0xFF	; 255
    1ac0:	e8 1a       	sub	r14, r24
    1ac2:	f8 0a       	sbc	r15, r24
    1ac4:	f0 92 a9 05 	sts	0x05A9, r15	; 0x8005a9 <xTickCount+0x1>
    1ac8:	e0 92 a8 05 	sts	0x05A8, r14	; 0x8005a8 <xTickCount>
    1acc:	e1 14       	cp	r14, r1
    1ace:	f1 04       	cpc	r15, r1
    1ad0:	b9 f4       	brne	.+46     	; 0x1b00 <xTaskIncrementTick+0x62>
    1ad2:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <pxDelayedTaskList>
    1ad6:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <pxDelayedTaskList+0x1>
    1ada:	20 91 be 05 	lds	r18, 0x05BE	; 0x8005be <pxOverflowDelayedTaskList>
    1ade:	30 91 bf 05 	lds	r19, 0x05BF	; 0x8005bf <pxOverflowDelayedTaskList+0x1>
    1ae2:	30 93 c1 05 	sts	0x05C1, r19	; 0x8005c1 <pxDelayedTaskList+0x1>
    1ae6:	20 93 c0 05 	sts	0x05C0, r18	; 0x8005c0 <pxDelayedTaskList>
    1aea:	90 93 bf 05 	sts	0x05BF, r25	; 0x8005bf <pxOverflowDelayedTaskList+0x1>
    1aee:	80 93 be 05 	sts	0x05BE, r24	; 0x8005be <pxOverflowDelayedTaskList>
    1af2:	80 91 a3 05 	lds	r24, 0x05A3	; 0x8005a3 <xNumOfOverflows>
    1af6:	8f 5f       	subi	r24, 0xFF	; 255
    1af8:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <xNumOfOverflows>
    1afc:	0e 94 a7 0b 	call	0x174e	; 0x174e <prvResetNextTaskUnblockTime>
    1b00:	80 91 a0 05 	lds	r24, 0x05A0	; 0x8005a0 <xNextTaskUnblockTime>
    1b04:	90 91 a1 05 	lds	r25, 0x05A1	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1b08:	e8 16       	cp	r14, r24
    1b0a:	f9 06       	cpc	r15, r25
    1b0c:	10 f4       	brcc	.+4      	; 0x1b12 <xTaskIncrementTick+0x74>
    1b0e:	d1 2c       	mov	r13, r1
    1b10:	53 c0       	rjmp	.+166    	; 0x1bb8 <xTaskIncrementTick+0x11a>
    1b12:	d1 2c       	mov	r13, r1
    1b14:	cc 24       	eor	r12, r12
    1b16:	c3 94       	inc	r12
    1b18:	e0 91 c0 05 	lds	r30, 0x05C0	; 0x8005c0 <pxDelayedTaskList>
    1b1c:	f0 91 c1 05 	lds	r31, 0x05C1	; 0x8005c1 <pxDelayedTaskList+0x1>
    1b20:	80 81       	ld	r24, Z
    1b22:	81 11       	cpse	r24, r1
    1b24:	07 c0       	rjmp	.+14     	; 0x1b34 <xTaskIncrementTick+0x96>
    1b26:	8f ef       	ldi	r24, 0xFF	; 255
    1b28:	9f ef       	ldi	r25, 0xFF	; 255
    1b2a:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1b2e:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <xNextTaskUnblockTime>
    1b32:	42 c0       	rjmp	.+132    	; 0x1bb8 <xTaskIncrementTick+0x11a>
    1b34:	e0 91 c0 05 	lds	r30, 0x05C0	; 0x8005c0 <pxDelayedTaskList>
    1b38:	f0 91 c1 05 	lds	r31, 0x05C1	; 0x8005c1 <pxDelayedTaskList+0x1>
    1b3c:	05 80       	ldd	r0, Z+5	; 0x05
    1b3e:	f6 81       	ldd	r31, Z+6	; 0x06
    1b40:	e0 2d       	mov	r30, r0
    1b42:	c6 81       	ldd	r28, Z+6	; 0x06
    1b44:	d7 81       	ldd	r29, Z+7	; 0x07
    1b46:	8a 81       	ldd	r24, Y+2	; 0x02
    1b48:	9b 81       	ldd	r25, Y+3	; 0x03
    1b4a:	e8 16       	cp	r14, r24
    1b4c:	f9 06       	cpc	r15, r25
    1b4e:	28 f4       	brcc	.+10     	; 0x1b5a <xTaskIncrementTick+0xbc>
    1b50:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <xNextTaskUnblockTime+0x1>
    1b54:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <xNextTaskUnblockTime>
    1b58:	2f c0       	rjmp	.+94     	; 0x1bb8 <xTaskIncrementTick+0x11a>
    1b5a:	8e 01       	movw	r16, r28
    1b5c:	0e 5f       	subi	r16, 0xFE	; 254
    1b5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b60:	c8 01       	movw	r24, r16
    1b62:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1b66:	8c 89       	ldd	r24, Y+20	; 0x14
    1b68:	9d 89       	ldd	r25, Y+21	; 0x15
    1b6a:	89 2b       	or	r24, r25
    1b6c:	21 f0       	breq	.+8      	; 0x1b76 <xTaskIncrementTick+0xd8>
    1b6e:	ce 01       	movw	r24, r28
    1b70:	0c 96       	adiw	r24, 0x0c	; 12
    1b72:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1b76:	8e 89       	ldd	r24, Y+22	; 0x16
    1b78:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    1b7c:	98 17       	cp	r25, r24
    1b7e:	10 f4       	brcc	.+4      	; 0x1b84 <xTaskIncrementTick+0xe6>
    1b80:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <uxTopReadyPriority>
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	9c 01       	movw	r18, r24
    1b88:	22 0f       	add	r18, r18
    1b8a:	33 1f       	adc	r19, r19
    1b8c:	22 0f       	add	r18, r18
    1b8e:	33 1f       	adc	r19, r19
    1b90:	22 0f       	add	r18, r18
    1b92:	33 1f       	adc	r19, r19
    1b94:	82 0f       	add	r24, r18
    1b96:	93 1f       	adc	r25, r19
    1b98:	b8 01       	movw	r22, r16
    1b9a:	8c 52       	subi	r24, 0x2C	; 44
    1b9c:	9a 4f       	sbci	r25, 0xFA	; 250
    1b9e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    1ba2:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1ba6:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1baa:	9e 89       	ldd	r25, Y+22	; 0x16
    1bac:	86 89       	ldd	r24, Z+22	; 0x16
    1bae:	98 17       	cp	r25, r24
    1bb0:	08 f4       	brcc	.+2      	; 0x1bb4 <xTaskIncrementTick+0x116>
    1bb2:	b2 cf       	rjmp	.-156    	; 0x1b18 <xTaskIncrementTick+0x7a>
    1bb4:	dc 2c       	mov	r13, r12
    1bb6:	b0 cf       	rjmp	.-160    	; 0x1b18 <xTaskIncrementTick+0x7a>
    1bb8:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1bbc:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1bc0:	86 89       	ldd	r24, Z+22	; 0x16
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	ee 0f       	add	r30, r30
    1bc8:	ff 1f       	adc	r31, r31
    1bca:	ee 0f       	add	r30, r30
    1bcc:	ff 1f       	adc	r31, r31
    1bce:	ee 0f       	add	r30, r30
    1bd0:	ff 1f       	adc	r31, r31
    1bd2:	8e 0f       	add	r24, r30
    1bd4:	9f 1f       	adc	r25, r31
    1bd6:	fc 01       	movw	r30, r24
    1bd8:	ec 52       	subi	r30, 0x2C	; 44
    1bda:	fa 4f       	sbci	r31, 0xFA	; 250
    1bdc:	80 81       	ld	r24, Z
    1bde:	82 30       	cpi	r24, 0x02	; 2
    1be0:	48 f0       	brcs	.+18     	; 0x1bf4 <xTaskIncrementTick+0x156>
    1be2:	dd 24       	eor	r13, r13
    1be4:	d3 94       	inc	r13
    1be6:	06 c0       	rjmp	.+12     	; 0x1bf4 <xTaskIncrementTick+0x156>
    1be8:	80 91 a5 05 	lds	r24, 0x05A5	; 0x8005a5 <uxPendedTicks>
    1bec:	8f 5f       	subi	r24, 0xFF	; 255
    1bee:	80 93 a5 05 	sts	0x05A5, r24	; 0x8005a5 <uxPendedTicks>
    1bf2:	d1 2c       	mov	r13, r1
    1bf4:	80 91 a4 05 	lds	r24, 0x05A4	; 0x8005a4 <xYieldPending>
    1bf8:	88 23       	and	r24, r24
    1bfa:	11 f0       	breq	.+4      	; 0x1c00 <xTaskIncrementTick+0x162>
    1bfc:	dd 24       	eor	r13, r13
    1bfe:	d3 94       	inc	r13
    1c00:	8d 2d       	mov	r24, r13
    1c02:	df 91       	pop	r29
    1c04:	cf 91       	pop	r28
    1c06:	1f 91       	pop	r17
    1c08:	0f 91       	pop	r16
    1c0a:	ff 90       	pop	r15
    1c0c:	ef 90       	pop	r14
    1c0e:	df 90       	pop	r13
    1c10:	cf 90       	pop	r12
    1c12:	08 95       	ret

00001c14 <xTaskResumeAll>:
    1c14:	df 92       	push	r13
    1c16:	ef 92       	push	r14
    1c18:	ff 92       	push	r15
    1c1a:	0f 93       	push	r16
    1c1c:	1f 93       	push	r17
    1c1e:	cf 93       	push	r28
    1c20:	df 93       	push	r29
    1c22:	0f b6       	in	r0, 0x3f	; 63
    1c24:	f8 94       	cli
    1c26:	0f 92       	push	r0
    1c28:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <uxSchedulerSuspended>
    1c2c:	81 50       	subi	r24, 0x01	; 1
    1c2e:	80 93 9d 05 	sts	0x059D, r24	; 0x80059d <uxSchedulerSuspended>
    1c32:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <uxSchedulerSuspended>
    1c36:	81 11       	cpse	r24, r1
    1c38:	5f c0       	rjmp	.+190    	; 0x1cf8 <xTaskResumeAll+0xe4>
    1c3a:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <uxCurrentNumberOfTasks>
    1c3e:	81 11       	cpse	r24, r1
    1c40:	33 c0       	rjmp	.+102    	; 0x1ca8 <xTaskResumeAll+0x94>
    1c42:	5d c0       	rjmp	.+186    	; 0x1cfe <xTaskResumeAll+0xea>
    1c44:	d7 01       	movw	r26, r14
    1c46:	15 96       	adiw	r26, 0x05	; 5
    1c48:	ed 91       	ld	r30, X+
    1c4a:	fc 91       	ld	r31, X
    1c4c:	16 97       	sbiw	r26, 0x06	; 6
    1c4e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c50:	d7 81       	ldd	r29, Z+7	; 0x07
    1c52:	ce 01       	movw	r24, r28
    1c54:	0c 96       	adiw	r24, 0x0c	; 12
    1c56:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1c5a:	8e 01       	movw	r16, r28
    1c5c:	0e 5f       	subi	r16, 0xFE	; 254
    1c5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c60:	c8 01       	movw	r24, r16
    1c62:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1c66:	8e 89       	ldd	r24, Y+22	; 0x16
    1c68:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    1c6c:	98 17       	cp	r25, r24
    1c6e:	10 f4       	brcc	.+4      	; 0x1c74 <xTaskResumeAll+0x60>
    1c70:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <uxTopReadyPriority>
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	9c 01       	movw	r18, r24
    1c78:	22 0f       	add	r18, r18
    1c7a:	33 1f       	adc	r19, r19
    1c7c:	22 0f       	add	r18, r18
    1c7e:	33 1f       	adc	r19, r19
    1c80:	22 0f       	add	r18, r18
    1c82:	33 1f       	adc	r19, r19
    1c84:	82 0f       	add	r24, r18
    1c86:	93 1f       	adc	r25, r19
    1c88:	b8 01       	movw	r22, r16
    1c8a:	8c 52       	subi	r24, 0x2C	; 44
    1c8c:	9a 4f       	sbci	r25, 0xFA	; 250
    1c8e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    1c92:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1c96:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1c9a:	9e 89       	ldd	r25, Y+22	; 0x16
    1c9c:	86 89       	ldd	r24, Z+22	; 0x16
    1c9e:	98 17       	cp	r25, r24
    1ca0:	68 f0       	brcs	.+26     	; 0x1cbc <xTaskResumeAll+0xa8>
    1ca2:	d0 92 a4 05 	sts	0x05A4, r13	; 0x8005a4 <xYieldPending>
    1ca6:	0a c0       	rjmp	.+20     	; 0x1cbc <xTaskResumeAll+0xa8>
    1ca8:	c0 e0       	ldi	r28, 0x00	; 0
    1caa:	d0 e0       	ldi	r29, 0x00	; 0
    1cac:	0f 2e       	mov	r0, r31
    1cae:	f5 eb       	ldi	r31, 0xB5	; 181
    1cb0:	ef 2e       	mov	r14, r31
    1cb2:	f5 e0       	ldi	r31, 0x05	; 5
    1cb4:	ff 2e       	mov	r15, r31
    1cb6:	f0 2d       	mov	r31, r0
    1cb8:	dd 24       	eor	r13, r13
    1cba:	d3 94       	inc	r13
    1cbc:	f7 01       	movw	r30, r14
    1cbe:	80 81       	ld	r24, Z
    1cc0:	81 11       	cpse	r24, r1
    1cc2:	c0 cf       	rjmp	.-128    	; 0x1c44 <xTaskResumeAll+0x30>
    1cc4:	cd 2b       	or	r28, r29
    1cc6:	11 f0       	breq	.+4      	; 0x1ccc <xTaskResumeAll+0xb8>
    1cc8:	0e 94 a7 0b 	call	0x174e	; 0x174e <prvResetNextTaskUnblockTime>
    1ccc:	c0 91 a5 05 	lds	r28, 0x05A5	; 0x8005a5 <uxPendedTicks>
    1cd0:	cc 23       	and	r28, r28
    1cd2:	51 f0       	breq	.+20     	; 0x1ce8 <xTaskResumeAll+0xd4>
    1cd4:	d1 e0       	ldi	r29, 0x01	; 1
    1cd6:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <xTaskIncrementTick>
    1cda:	81 11       	cpse	r24, r1
    1cdc:	d0 93 a4 05 	sts	0x05A4, r29	; 0x8005a4 <xYieldPending>
    1ce0:	c1 50       	subi	r28, 0x01	; 1
    1ce2:	c9 f7       	brne	.-14     	; 0x1cd6 <xTaskResumeAll+0xc2>
    1ce4:	10 92 a5 05 	sts	0x05A5, r1	; 0x8005a5 <uxPendedTicks>
    1ce8:	80 91 a4 05 	lds	r24, 0x05A4	; 0x8005a4 <xYieldPending>
    1cec:	88 23       	and	r24, r24
    1cee:	31 f0       	breq	.+12     	; 0x1cfc <xTaskResumeAll+0xe8>
    1cf0:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	03 c0       	rjmp	.+6      	; 0x1cfe <xTaskResumeAll+0xea>
    1cf8:	80 e0       	ldi	r24, 0x00	; 0
    1cfa:	01 c0       	rjmp	.+2      	; 0x1cfe <xTaskResumeAll+0xea>
    1cfc:	80 e0       	ldi	r24, 0x00	; 0
    1cfe:	0f 90       	pop	r0
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	1f 91       	pop	r17
    1d08:	0f 91       	pop	r16
    1d0a:	ff 90       	pop	r15
    1d0c:	ef 90       	pop	r14
    1d0e:	df 90       	pop	r13
    1d10:	08 95       	ret

00001d12 <vTaskDelay>:
    1d12:	cf 93       	push	r28
    1d14:	df 93       	push	r29
    1d16:	ec 01       	movw	r28, r24
    1d18:	89 2b       	or	r24, r25
    1d1a:	51 f0       	breq	.+20     	; 0x1d30 <vTaskDelay+0x1e>
    1d1c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vTaskSuspendAll>
    1d20:	60 e0       	ldi	r22, 0x00	; 0
    1d22:	ce 01       	movw	r24, r28
    1d24:	0e 94 c6 0b 	call	0x178c	; 0x178c <prvAddCurrentTaskToDelayedList>
    1d28:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    1d2c:	81 11       	cpse	r24, r1
    1d2e:	02 c0       	rjmp	.+4      	; 0x1d34 <vTaskDelay+0x22>
    1d30:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    1d34:	df 91       	pop	r29
    1d36:	cf 91       	pop	r28
    1d38:	08 95       	ret

00001d3a <prvIdleTask>:
    1d3a:	0c ea       	ldi	r16, 0xAC	; 172
    1d3c:	15 e0       	ldi	r17, 0x05	; 5
    1d3e:	0f 2e       	mov	r0, r31
    1d40:	f4 ed       	ldi	r31, 0xD4	; 212
    1d42:	ef 2e       	mov	r14, r31
    1d44:	f5 e0       	ldi	r31, 0x05	; 5
    1d46:	ff 2e       	mov	r15, r31
    1d48:	f0 2d       	mov	r31, r0
    1d4a:	29 c0       	rjmp	.+82     	; 0x1d9e <prvIdleTask+0x64>
    1d4c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <vTaskSuspendAll>
    1d50:	d8 01       	movw	r26, r16
    1d52:	cc 91       	ld	r28, X
    1d54:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <xTaskResumeAll>
    1d58:	cc 23       	and	r28, r28
    1d5a:	09 f1       	breq	.+66     	; 0x1d9e <prvIdleTask+0x64>
    1d5c:	0f b6       	in	r0, 0x3f	; 63
    1d5e:	f8 94       	cli
    1d60:	0f 92       	push	r0
    1d62:	d8 01       	movw	r26, r16
    1d64:	15 96       	adiw	r26, 0x05	; 5
    1d66:	ed 91       	ld	r30, X+
    1d68:	fc 91       	ld	r31, X
    1d6a:	16 97       	sbiw	r26, 0x06	; 6
    1d6c:	c6 81       	ldd	r28, Z+6	; 0x06
    1d6e:	d7 81       	ldd	r29, Z+7	; 0x07
    1d70:	ce 01       	movw	r24, r28
    1d72:	02 96       	adiw	r24, 0x02	; 2
    1d74:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1d78:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <uxCurrentNumberOfTasks>
    1d7c:	81 50       	subi	r24, 0x01	; 1
    1d7e:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <uxCurrentNumberOfTasks>
    1d82:	80 91 ab 05 	lds	r24, 0x05AB	; 0x8005ab <uxDeletedTasksWaitingCleanUp>
    1d86:	81 50       	subi	r24, 0x01	; 1
    1d88:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <uxDeletedTasksWaitingCleanUp>
    1d8c:	0f 90       	pop	r0
    1d8e:	0f be       	out	0x3f, r0	; 63
    1d90:	8f 89       	ldd	r24, Y+23	; 0x17
    1d92:	98 8d       	ldd	r25, Y+24	; 0x18
    1d94:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <vPortFree>
    1d98:	ce 01       	movw	r24, r28
    1d9a:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <vPortFree>
    1d9e:	80 91 ab 05 	lds	r24, 0x05AB	; 0x8005ab <uxDeletedTasksWaitingCleanUp>
    1da2:	81 11       	cpse	r24, r1
    1da4:	d3 cf       	rjmp	.-90     	; 0x1d4c <prvIdleTask+0x12>
    1da6:	f7 01       	movw	r30, r14
    1da8:	80 81       	ld	r24, Z
    1daa:	82 30       	cpi	r24, 0x02	; 2
    1dac:	10 f0       	brcs	.+4      	; 0x1db2 <prvIdleTask+0x78>
    1dae:	0e 94 fb 05 	call	0xbf6	; 0xbf6 <vPortYield>
    1db2:	0e 94 ae 03 	call	0x75c	; 0x75c <vApplicationIdleHook>
    1db6:	f3 cf       	rjmp	.-26     	; 0x1d9e <prvIdleTask+0x64>

00001db8 <vTaskSetApplicationTaskTag>:
    1db8:	00 97       	sbiw	r24, 0x00	; 0
    1dba:	21 f4       	brne	.+8      	; 0x1dc4 <vTaskSetApplicationTaskTag+0xc>
    1dbc:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1dc0:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	0f 92       	push	r0
    1dca:	fc 01       	movw	r30, r24
    1dcc:	76 a3       	std	Z+38, r23	; 0x26
    1dce:	65 a3       	std	Z+37, r22	; 0x25
    1dd0:	0f 90       	pop	r0
    1dd2:	0f be       	out	0x3f, r0	; 63
    1dd4:	08 95       	ret

00001dd6 <vTaskSwitchContext>:
    1dd6:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <uxSchedulerSuspended>
    1dda:	88 23       	and	r24, r24
    1ddc:	21 f0       	breq	.+8      	; 0x1de6 <vTaskSwitchContext+0x10>
    1dde:	81 e0       	ldi	r24, 0x01	; 1
    1de0:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <xYieldPending>
    1de4:	08 95       	ret
    1de6:	10 92 a4 05 	sts	0x05A4, r1	; 0x8005a4 <xYieldPending>
    1dea:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1dee:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1df2:	85 a1       	ldd	r24, Z+37	; 0x25
    1df4:	0e 94 84 04 	call	0x908	; 0x908 <switch_out>
    1df8:	20 91 a7 05 	lds	r18, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    1dfc:	82 2f       	mov	r24, r18
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	fc 01       	movw	r30, r24
    1e02:	ee 0f       	add	r30, r30
    1e04:	ff 1f       	adc	r31, r31
    1e06:	ee 0f       	add	r30, r30
    1e08:	ff 1f       	adc	r31, r31
    1e0a:	ee 0f       	add	r30, r30
    1e0c:	ff 1f       	adc	r31, r31
    1e0e:	e8 0f       	add	r30, r24
    1e10:	f9 1f       	adc	r31, r25
    1e12:	ec 52       	subi	r30, 0x2C	; 44
    1e14:	fa 4f       	sbci	r31, 0xFA	; 250
    1e16:	30 81       	ld	r19, Z
    1e18:	31 11       	cpse	r19, r1
    1e1a:	11 c0       	rjmp	.+34     	; 0x1e3e <vTaskSwitchContext+0x68>
    1e1c:	21 50       	subi	r18, 0x01	; 1
    1e1e:	82 2f       	mov	r24, r18
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	fc 01       	movw	r30, r24
    1e24:	ee 0f       	add	r30, r30
    1e26:	ff 1f       	adc	r31, r31
    1e28:	ee 0f       	add	r30, r30
    1e2a:	ff 1f       	adc	r31, r31
    1e2c:	ee 0f       	add	r30, r30
    1e2e:	ff 1f       	adc	r31, r31
    1e30:	e8 0f       	add	r30, r24
    1e32:	f9 1f       	adc	r31, r25
    1e34:	ec 52       	subi	r30, 0x2C	; 44
    1e36:	fa 4f       	sbci	r31, 0xFA	; 250
    1e38:	30 81       	ld	r19, Z
    1e3a:	33 23       	and	r19, r19
    1e3c:	79 f3       	breq	.-34     	; 0x1e1c <vTaskSwitchContext+0x46>
    1e3e:	ac 01       	movw	r20, r24
    1e40:	44 0f       	add	r20, r20
    1e42:	55 1f       	adc	r21, r21
    1e44:	44 0f       	add	r20, r20
    1e46:	55 1f       	adc	r21, r21
    1e48:	44 0f       	add	r20, r20
    1e4a:	55 1f       	adc	r21, r21
    1e4c:	48 0f       	add	r20, r24
    1e4e:	59 1f       	adc	r21, r25
    1e50:	da 01       	movw	r26, r20
    1e52:	ac 52       	subi	r26, 0x2C	; 44
    1e54:	ba 4f       	sbci	r27, 0xFA	; 250
    1e56:	11 96       	adiw	r26, 0x01	; 1
    1e58:	ed 91       	ld	r30, X+
    1e5a:	fc 91       	ld	r31, X
    1e5c:	12 97       	sbiw	r26, 0x02	; 2
    1e5e:	02 80       	ldd	r0, Z+2	; 0x02
    1e60:	f3 81       	ldd	r31, Z+3	; 0x03
    1e62:	e0 2d       	mov	r30, r0
    1e64:	12 96       	adiw	r26, 0x02	; 2
    1e66:	fc 93       	st	X, r31
    1e68:	ee 93       	st	-X, r30
    1e6a:	11 97       	sbiw	r26, 0x01	; 1
    1e6c:	49 52       	subi	r20, 0x29	; 41
    1e6e:	5a 4f       	sbci	r21, 0xFA	; 250
    1e70:	e4 17       	cp	r30, r20
    1e72:	f5 07       	cpc	r31, r21
    1e74:	29 f4       	brne	.+10     	; 0x1e80 <vTaskSwitchContext+0xaa>
    1e76:	42 81       	ldd	r20, Z+2	; 0x02
    1e78:	53 81       	ldd	r21, Z+3	; 0x03
    1e7a:	fd 01       	movw	r30, r26
    1e7c:	52 83       	std	Z+2, r21	; 0x02
    1e7e:	41 83       	std	Z+1, r20	; 0x01
    1e80:	fc 01       	movw	r30, r24
    1e82:	ee 0f       	add	r30, r30
    1e84:	ff 1f       	adc	r31, r31
    1e86:	ee 0f       	add	r30, r30
    1e88:	ff 1f       	adc	r31, r31
    1e8a:	ee 0f       	add	r30, r30
    1e8c:	ff 1f       	adc	r31, r31
    1e8e:	8e 0f       	add	r24, r30
    1e90:	9f 1f       	adc	r25, r31
    1e92:	fc 01       	movw	r30, r24
    1e94:	ec 52       	subi	r30, 0x2C	; 44
    1e96:	fa 4f       	sbci	r31, 0xFA	; 250
    1e98:	01 80       	ldd	r0, Z+1	; 0x01
    1e9a:	f2 81       	ldd	r31, Z+2	; 0x02
    1e9c:	e0 2d       	mov	r30, r0
    1e9e:	86 81       	ldd	r24, Z+6	; 0x06
    1ea0:	97 81       	ldd	r25, Z+7	; 0x07
    1ea2:	90 93 f9 05 	sts	0x05F9, r25	; 0x8005f9 <pxCurrentTCB+0x1>
    1ea6:	80 93 f8 05 	sts	0x05F8, r24	; 0x8005f8 <pxCurrentTCB>
    1eaa:	20 93 a7 05 	sts	0x05A7, r18	; 0x8005a7 <uxTopReadyPriority>
    1eae:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1eb2:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1eb6:	85 a1       	ldd	r24, Z+37	; 0x25
    1eb8:	0e 94 79 04 	call	0x8f2	; 0x8f2 <switch_in>
    1ebc:	08 95       	ret

00001ebe <vTaskPlaceOnEventList>:
    1ebe:	cf 93       	push	r28
    1ec0:	df 93       	push	r29
    1ec2:	eb 01       	movw	r28, r22
    1ec4:	60 91 f8 05 	lds	r22, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1ec8:	70 91 f9 05 	lds	r23, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1ecc:	64 5f       	subi	r22, 0xF4	; 244
    1ece:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed0:	0e 94 fe 04 	call	0x9fc	; 0x9fc <vListInsert>
    1ed4:	61 e0       	ldi	r22, 0x01	; 1
    1ed6:	ce 01       	movw	r24, r28
    1ed8:	0e 94 c6 0b 	call	0x178c	; 0x178c <prvAddCurrentTaskToDelayedList>
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
    1ee0:	08 95       	ret

00001ee2 <xTaskRemoveFromEventList>:
    1ee2:	0f 93       	push	r16
    1ee4:	1f 93       	push	r17
    1ee6:	cf 93       	push	r28
    1ee8:	df 93       	push	r29
    1eea:	dc 01       	movw	r26, r24
    1eec:	15 96       	adiw	r26, 0x05	; 5
    1eee:	ed 91       	ld	r30, X+
    1ef0:	fc 91       	ld	r31, X
    1ef2:	16 97       	sbiw	r26, 0x06	; 6
    1ef4:	c6 81       	ldd	r28, Z+6	; 0x06
    1ef6:	d7 81       	ldd	r29, Z+7	; 0x07
    1ef8:	8e 01       	movw	r16, r28
    1efa:	04 5f       	subi	r16, 0xF4	; 244
    1efc:	1f 4f       	sbci	r17, 0xFF	; 255
    1efe:	c8 01       	movw	r24, r16
    1f00:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1f04:	80 91 9d 05 	lds	r24, 0x059D	; 0x80059d <uxSchedulerSuspended>
    1f08:	81 11       	cpse	r24, r1
    1f0a:	1c c0       	rjmp	.+56     	; 0x1f44 <xTaskRemoveFromEventList+0x62>
    1f0c:	0a 50       	subi	r16, 0x0A	; 10
    1f0e:	11 09       	sbc	r17, r1
    1f10:	c8 01       	movw	r24, r16
    1f12:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    1f16:	8e 89       	ldd	r24, Y+22	; 0x16
    1f18:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    1f1c:	98 17       	cp	r25, r24
    1f1e:	10 f4       	brcc	.+4      	; 0x1f24 <xTaskRemoveFromEventList+0x42>
    1f20:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <uxTopReadyPriority>
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	9c 01       	movw	r18, r24
    1f28:	22 0f       	add	r18, r18
    1f2a:	33 1f       	adc	r19, r19
    1f2c:	22 0f       	add	r18, r18
    1f2e:	33 1f       	adc	r19, r19
    1f30:	22 0f       	add	r18, r18
    1f32:	33 1f       	adc	r19, r19
    1f34:	82 0f       	add	r24, r18
    1f36:	93 1f       	adc	r25, r19
    1f38:	b8 01       	movw	r22, r16
    1f3a:	8c 52       	subi	r24, 0x2C	; 44
    1f3c:	9a 4f       	sbci	r25, 0xFA	; 250
    1f3e:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    1f42:	05 c0       	rjmp	.+10     	; 0x1f4e <xTaskRemoveFromEventList+0x6c>
    1f44:	b8 01       	movw	r22, r16
    1f46:	85 eb       	ldi	r24, 0xB5	; 181
    1f48:	95 e0       	ldi	r25, 0x05	; 5
    1f4a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    1f4e:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    1f52:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    1f56:	9e 89       	ldd	r25, Y+22	; 0x16
    1f58:	86 89       	ldd	r24, Z+22	; 0x16
    1f5a:	89 17       	cp	r24, r25
    1f5c:	20 f4       	brcc	.+8      	; 0x1f66 <xTaskRemoveFromEventList+0x84>
    1f5e:	81 e0       	ldi	r24, 0x01	; 1
    1f60:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <xYieldPending>
    1f64:	01 c0       	rjmp	.+2      	; 0x1f68 <xTaskRemoveFromEventList+0x86>
    1f66:	80 e0       	ldi	r24, 0x00	; 0
    1f68:	df 91       	pop	r29
    1f6a:	cf 91       	pop	r28
    1f6c:	1f 91       	pop	r17
    1f6e:	0f 91       	pop	r16
    1f70:	08 95       	ret

00001f72 <vTaskSetTimeOutState>:
    1f72:	20 91 a3 05 	lds	r18, 0x05A3	; 0x8005a3 <xNumOfOverflows>
    1f76:	fc 01       	movw	r30, r24
    1f78:	20 83       	st	Z, r18
    1f7a:	20 91 a8 05 	lds	r18, 0x05A8	; 0x8005a8 <xTickCount>
    1f7e:	30 91 a9 05 	lds	r19, 0x05A9	; 0x8005a9 <xTickCount+0x1>
    1f82:	32 83       	std	Z+2, r19	; 0x02
    1f84:	21 83       	std	Z+1, r18	; 0x01
    1f86:	08 95       	ret

00001f88 <xTaskCheckForTimeOut>:
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
    1f8c:	fc 01       	movw	r30, r24
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	0f 92       	push	r0
    1f94:	20 91 a8 05 	lds	r18, 0x05A8	; 0x8005a8 <xTickCount>
    1f98:	30 91 a9 05 	lds	r19, 0x05A9	; 0x8005a9 <xTickCount+0x1>
    1f9c:	80 91 a3 05 	lds	r24, 0x05A3	; 0x8005a3 <xNumOfOverflows>
    1fa0:	90 81       	ld	r25, Z
    1fa2:	98 17       	cp	r25, r24
    1fa4:	29 f0       	breq	.+10     	; 0x1fb0 <xTaskCheckForTimeOut+0x28>
    1fa6:	81 81       	ldd	r24, Z+1	; 0x01
    1fa8:	92 81       	ldd	r25, Z+2	; 0x02
    1faa:	28 17       	cp	r18, r24
    1fac:	39 07       	cpc	r19, r25
    1fae:	b0 f4       	brcc	.+44     	; 0x1fdc <xTaskCheckForTimeOut+0x54>
    1fb0:	a1 81       	ldd	r26, Z+1	; 0x01
    1fb2:	b2 81       	ldd	r27, Z+2	; 0x02
    1fb4:	eb 01       	movw	r28, r22
    1fb6:	48 81       	ld	r20, Y
    1fb8:	59 81       	ldd	r21, Y+1	; 0x01
    1fba:	c9 01       	movw	r24, r18
    1fbc:	8a 1b       	sub	r24, r26
    1fbe:	9b 0b       	sbc	r25, r27
    1fc0:	84 17       	cp	r24, r20
    1fc2:	95 07       	cpc	r25, r21
    1fc4:	68 f4       	brcc	.+26     	; 0x1fe0 <xTaskCheckForTimeOut+0x58>
    1fc6:	cf 01       	movw	r24, r30
    1fc8:	a2 1b       	sub	r26, r18
    1fca:	b3 0b       	sbc	r27, r19
    1fcc:	4a 0f       	add	r20, r26
    1fce:	5b 1f       	adc	r21, r27
    1fd0:	59 83       	std	Y+1, r21	; 0x01
    1fd2:	48 83       	st	Y, r20
    1fd4:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <vTaskSetTimeOutState>
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
    1fda:	03 c0       	rjmp	.+6      	; 0x1fe2 <xTaskCheckForTimeOut+0x5a>
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	01 c0       	rjmp	.+2      	; 0x1fe2 <xTaskCheckForTimeOut+0x5a>
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	0f 90       	pop	r0
    1fe4:	0f be       	out	0x3f, r0	; 63
    1fe6:	df 91       	pop	r29
    1fe8:	cf 91       	pop	r28
    1fea:	08 95       	ret

00001fec <vTaskMissedYield>:
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <xYieldPending>
    1ff2:	08 95       	ret

00001ff4 <vTaskPriorityInherit>:
    1ff4:	0f 93       	push	r16
    1ff6:	1f 93       	push	r17
    1ff8:	cf 93       	push	r28
    1ffa:	df 93       	push	r29
    1ffc:	fc 01       	movw	r30, r24
    1ffe:	89 2b       	or	r24, r25
    2000:	09 f4       	brne	.+2      	; 0x2004 <vTaskPriorityInherit+0x10>
    2002:	55 c0       	rjmp	.+170    	; 0x20ae <vTaskPriorityInherit+0xba>
    2004:	26 89       	ldd	r18, Z+22	; 0x16
    2006:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    200a:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    200e:	56 96       	adiw	r26, 0x16	; 22
    2010:	8c 91       	ld	r24, X
    2012:	28 17       	cp	r18, r24
    2014:	08 f0       	brcs	.+2      	; 0x2018 <vTaskPriorityInherit+0x24>
    2016:	4b c0       	rjmp	.+150    	; 0x20ae <vTaskPriorityInherit+0xba>
    2018:	84 85       	ldd	r24, Z+12	; 0x0c
    201a:	95 85       	ldd	r25, Z+13	; 0x0d
    201c:	99 23       	and	r25, r25
    201e:	64 f0       	brlt	.+24     	; 0x2038 <vTaskPriorityInherit+0x44>
    2020:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    2024:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    2028:	56 96       	adiw	r26, 0x16	; 22
    202a:	3c 91       	ld	r19, X
    202c:	84 e0       	ldi	r24, 0x04	; 4
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	83 1b       	sub	r24, r19
    2032:	91 09       	sbc	r25, r1
    2034:	95 87       	std	Z+13, r25	; 0x0d
    2036:	84 87       	std	Z+12, r24	; 0x0c
    2038:	30 e0       	ldi	r19, 0x00	; 0
    203a:	c9 01       	movw	r24, r18
    203c:	88 0f       	add	r24, r24
    203e:	99 1f       	adc	r25, r25
    2040:	88 0f       	add	r24, r24
    2042:	99 1f       	adc	r25, r25
    2044:	88 0f       	add	r24, r24
    2046:	99 1f       	adc	r25, r25
    2048:	28 0f       	add	r18, r24
    204a:	39 1f       	adc	r19, r25
    204c:	2c 52       	subi	r18, 0x2C	; 44
    204e:	3a 4f       	sbci	r19, 0xFA	; 250
    2050:	82 85       	ldd	r24, Z+10	; 0x0a
    2052:	93 85       	ldd	r25, Z+11	; 0x0b
    2054:	82 17       	cp	r24, r18
    2056:	93 07       	cpc	r25, r19
    2058:	19 f5       	brne	.+70     	; 0x20a0 <vTaskPriorityInherit+0xac>
    205a:	8f 01       	movw	r16, r30
    205c:	ef 01       	movw	r28, r30
    205e:	22 96       	adiw	r28, 0x02	; 2
    2060:	ce 01       	movw	r24, r28
    2062:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    2066:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    206a:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    206e:	86 89       	ldd	r24, Z+22	; 0x16
    2070:	f8 01       	movw	r30, r16
    2072:	86 8b       	std	Z+22, r24	; 0x16
    2074:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    2078:	98 17       	cp	r25, r24
    207a:	10 f4       	brcc	.+4      	; 0x2080 <vTaskPriorityInherit+0x8c>
    207c:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <uxTopReadyPriority>
    2080:	90 e0       	ldi	r25, 0x00	; 0
    2082:	9c 01       	movw	r18, r24
    2084:	22 0f       	add	r18, r18
    2086:	33 1f       	adc	r19, r19
    2088:	22 0f       	add	r18, r18
    208a:	33 1f       	adc	r19, r19
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	82 0f       	add	r24, r18
    2092:	93 1f       	adc	r25, r19
    2094:	be 01       	movw	r22, r28
    2096:	8c 52       	subi	r24, 0x2C	; 44
    2098:	9a 4f       	sbci	r25, 0xFA	; 250
    209a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    209e:	07 c0       	rjmp	.+14     	; 0x20ae <vTaskPriorityInherit+0xba>
    20a0:	a0 91 f8 05 	lds	r26, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    20a4:	b0 91 f9 05 	lds	r27, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    20a8:	56 96       	adiw	r26, 0x16	; 22
    20aa:	8c 91       	ld	r24, X
    20ac:	86 8b       	std	Z+22, r24	; 0x16
    20ae:	df 91       	pop	r29
    20b0:	cf 91       	pop	r28
    20b2:	1f 91       	pop	r17
    20b4:	0f 91       	pop	r16
    20b6:	08 95       	ret

000020b8 <xTaskPriorityDisinherit>:
    20b8:	0f 93       	push	r16
    20ba:	1f 93       	push	r17
    20bc:	cf 93       	push	r28
    20be:	df 93       	push	r29
    20c0:	fc 01       	movw	r30, r24
    20c2:	89 2b       	or	r24, r25
    20c4:	79 f1       	breq	.+94     	; 0x2124 <xTaskPriorityDisinherit+0x6c>
    20c6:	84 a1       	ldd	r24, Z+36	; 0x24
    20c8:	81 50       	subi	r24, 0x01	; 1
    20ca:	84 a3       	std	Z+36, r24	; 0x24
    20cc:	26 89       	ldd	r18, Z+22	; 0x16
    20ce:	93 a1       	ldd	r25, Z+35	; 0x23
    20d0:	29 17       	cp	r18, r25
    20d2:	51 f1       	breq	.+84     	; 0x2128 <xTaskPriorityDisinherit+0x70>
    20d4:	81 11       	cpse	r24, r1
    20d6:	2a c0       	rjmp	.+84     	; 0x212c <xTaskPriorityDisinherit+0x74>
    20d8:	ef 01       	movw	r28, r30
    20da:	8f 01       	movw	r16, r30
    20dc:	0e 5f       	subi	r16, 0xFE	; 254
    20de:	1f 4f       	sbci	r17, 0xFF	; 255
    20e0:	c8 01       	movw	r24, r16
    20e2:	0e 94 2f 05 	call	0xa5e	; 0xa5e <uxListRemove>
    20e6:	8b a1       	ldd	r24, Y+35	; 0x23
    20e8:	8e 8b       	std	Y+22, r24	; 0x16
    20ea:	24 e0       	ldi	r18, 0x04	; 4
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	28 1b       	sub	r18, r24
    20f0:	31 09       	sbc	r19, r1
    20f2:	3d 87       	std	Y+13, r19	; 0x0d
    20f4:	2c 87       	std	Y+12, r18	; 0x0c
    20f6:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <uxTopReadyPriority>
    20fa:	98 17       	cp	r25, r24
    20fc:	10 f4       	brcc	.+4      	; 0x2102 <xTaskPriorityDisinherit+0x4a>
    20fe:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <uxTopReadyPriority>
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	9c 01       	movw	r18, r24
    2106:	22 0f       	add	r18, r18
    2108:	33 1f       	adc	r19, r19
    210a:	22 0f       	add	r18, r18
    210c:	33 1f       	adc	r19, r19
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	82 0f       	add	r24, r18
    2114:	93 1f       	adc	r25, r19
    2116:	b8 01       	movw	r22, r16
    2118:	8c 52       	subi	r24, 0x2C	; 44
    211a:	9a 4f       	sbci	r25, 0xFA	; 250
    211c:	0e 94 dd 04 	call	0x9ba	; 0x9ba <vListInsertEnd>
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	05 c0       	rjmp	.+10     	; 0x212e <xTaskPriorityDisinherit+0x76>
    2124:	80 e0       	ldi	r24, 0x00	; 0
    2126:	03 c0       	rjmp	.+6      	; 0x212e <xTaskPriorityDisinherit+0x76>
    2128:	80 e0       	ldi	r24, 0x00	; 0
    212a:	01 c0       	rjmp	.+2      	; 0x212e <xTaskPriorityDisinherit+0x76>
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	1f 91       	pop	r17
    2134:	0f 91       	pop	r16
    2136:	08 95       	ret

00002138 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2138:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    213c:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    2140:	89 2b       	or	r24, r25
    2142:	39 f0       	breq	.+14     	; 0x2152 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2144:	e0 91 f8 05 	lds	r30, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    2148:	f0 91 f9 05 	lds	r31, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
    214c:	84 a1       	ldd	r24, Z+36	; 0x24
    214e:	8f 5f       	subi	r24, 0xFF	; 255
    2150:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    2152:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <pxCurrentTCB>
    2156:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <pxCurrentTCB+0x1>
	}
    215a:	08 95       	ret

0000215c <__udivmodsi4>:
    215c:	a1 e2       	ldi	r26, 0x21	; 33
    215e:	1a 2e       	mov	r1, r26
    2160:	aa 1b       	sub	r26, r26
    2162:	bb 1b       	sub	r27, r27
    2164:	fd 01       	movw	r30, r26
    2166:	0d c0       	rjmp	.+26     	; 0x2182 <__udivmodsi4_ep>

00002168 <__udivmodsi4_loop>:
    2168:	aa 1f       	adc	r26, r26
    216a:	bb 1f       	adc	r27, r27
    216c:	ee 1f       	adc	r30, r30
    216e:	ff 1f       	adc	r31, r31
    2170:	a2 17       	cp	r26, r18
    2172:	b3 07       	cpc	r27, r19
    2174:	e4 07       	cpc	r30, r20
    2176:	f5 07       	cpc	r31, r21
    2178:	20 f0       	brcs	.+8      	; 0x2182 <__udivmodsi4_ep>
    217a:	a2 1b       	sub	r26, r18
    217c:	b3 0b       	sbc	r27, r19
    217e:	e4 0b       	sbc	r30, r20
    2180:	f5 0b       	sbc	r31, r21

00002182 <__udivmodsi4_ep>:
    2182:	66 1f       	adc	r22, r22
    2184:	77 1f       	adc	r23, r23
    2186:	88 1f       	adc	r24, r24
    2188:	99 1f       	adc	r25, r25
    218a:	1a 94       	dec	r1
    218c:	69 f7       	brne	.-38     	; 0x2168 <__udivmodsi4_loop>
    218e:	60 95       	com	r22
    2190:	70 95       	com	r23
    2192:	80 95       	com	r24
    2194:	90 95       	com	r25
    2196:	9b 01       	movw	r18, r22
    2198:	ac 01       	movw	r20, r24
    219a:	bd 01       	movw	r22, r26
    219c:	cf 01       	movw	r24, r30
    219e:	08 95       	ret

000021a0 <malloc>:
    21a0:	0f 93       	push	r16
    21a2:	1f 93       	push	r17
    21a4:	cf 93       	push	r28
    21a6:	df 93       	push	r29
    21a8:	82 30       	cpi	r24, 0x02	; 2
    21aa:	91 05       	cpc	r25, r1
    21ac:	10 f4       	brcc	.+4      	; 0x21b2 <malloc+0x12>
    21ae:	82 e0       	ldi	r24, 0x02	; 2
    21b0:	90 e0       	ldi	r25, 0x00	; 0
    21b2:	e0 91 14 07 	lds	r30, 0x0714	; 0x800714 <__flp>
    21b6:	f0 91 15 07 	lds	r31, 0x0715	; 0x800715 <__flp+0x1>
    21ba:	20 e0       	ldi	r18, 0x00	; 0
    21bc:	30 e0       	ldi	r19, 0x00	; 0
    21be:	a0 e0       	ldi	r26, 0x00	; 0
    21c0:	b0 e0       	ldi	r27, 0x00	; 0
    21c2:	30 97       	sbiw	r30, 0x00	; 0
    21c4:	19 f1       	breq	.+70     	; 0x220c <malloc+0x6c>
    21c6:	40 81       	ld	r20, Z
    21c8:	51 81       	ldd	r21, Z+1	; 0x01
    21ca:	02 81       	ldd	r16, Z+2	; 0x02
    21cc:	13 81       	ldd	r17, Z+3	; 0x03
    21ce:	48 17       	cp	r20, r24
    21d0:	59 07       	cpc	r21, r25
    21d2:	c8 f0       	brcs	.+50     	; 0x2206 <malloc+0x66>
    21d4:	84 17       	cp	r24, r20
    21d6:	95 07       	cpc	r25, r21
    21d8:	69 f4       	brne	.+26     	; 0x21f4 <malloc+0x54>
    21da:	10 97       	sbiw	r26, 0x00	; 0
    21dc:	31 f0       	breq	.+12     	; 0x21ea <malloc+0x4a>
    21de:	12 96       	adiw	r26, 0x02	; 2
    21e0:	0c 93       	st	X, r16
    21e2:	12 97       	sbiw	r26, 0x02	; 2
    21e4:	13 96       	adiw	r26, 0x03	; 3
    21e6:	1c 93       	st	X, r17
    21e8:	27 c0       	rjmp	.+78     	; 0x2238 <malloc+0x98>
    21ea:	00 93 14 07 	sts	0x0714, r16	; 0x800714 <__flp>
    21ee:	10 93 15 07 	sts	0x0715, r17	; 0x800715 <__flp+0x1>
    21f2:	22 c0       	rjmp	.+68     	; 0x2238 <malloc+0x98>
    21f4:	21 15       	cp	r18, r1
    21f6:	31 05       	cpc	r19, r1
    21f8:	19 f0       	breq	.+6      	; 0x2200 <malloc+0x60>
    21fa:	42 17       	cp	r20, r18
    21fc:	53 07       	cpc	r21, r19
    21fe:	18 f4       	brcc	.+6      	; 0x2206 <malloc+0x66>
    2200:	9a 01       	movw	r18, r20
    2202:	bd 01       	movw	r22, r26
    2204:	ef 01       	movw	r28, r30
    2206:	df 01       	movw	r26, r30
    2208:	f8 01       	movw	r30, r16
    220a:	db cf       	rjmp	.-74     	; 0x21c2 <malloc+0x22>
    220c:	21 15       	cp	r18, r1
    220e:	31 05       	cpc	r19, r1
    2210:	f9 f0       	breq	.+62     	; 0x2250 <malloc+0xb0>
    2212:	28 1b       	sub	r18, r24
    2214:	39 0b       	sbc	r19, r25
    2216:	24 30       	cpi	r18, 0x04	; 4
    2218:	31 05       	cpc	r19, r1
    221a:	80 f4       	brcc	.+32     	; 0x223c <malloc+0x9c>
    221c:	8a 81       	ldd	r24, Y+2	; 0x02
    221e:	9b 81       	ldd	r25, Y+3	; 0x03
    2220:	61 15       	cp	r22, r1
    2222:	71 05       	cpc	r23, r1
    2224:	21 f0       	breq	.+8      	; 0x222e <malloc+0x8e>
    2226:	fb 01       	movw	r30, r22
    2228:	93 83       	std	Z+3, r25	; 0x03
    222a:	82 83       	std	Z+2, r24	; 0x02
    222c:	04 c0       	rjmp	.+8      	; 0x2236 <malloc+0x96>
    222e:	90 93 15 07 	sts	0x0715, r25	; 0x800715 <__flp+0x1>
    2232:	80 93 14 07 	sts	0x0714, r24	; 0x800714 <__flp>
    2236:	fe 01       	movw	r30, r28
    2238:	32 96       	adiw	r30, 0x02	; 2
    223a:	44 c0       	rjmp	.+136    	; 0x22c4 <malloc+0x124>
    223c:	fe 01       	movw	r30, r28
    223e:	e2 0f       	add	r30, r18
    2240:	f3 1f       	adc	r31, r19
    2242:	81 93       	st	Z+, r24
    2244:	91 93       	st	Z+, r25
    2246:	22 50       	subi	r18, 0x02	; 2
    2248:	31 09       	sbc	r19, r1
    224a:	39 83       	std	Y+1, r19	; 0x01
    224c:	28 83       	st	Y, r18
    224e:	3a c0       	rjmp	.+116    	; 0x22c4 <malloc+0x124>
    2250:	20 91 12 07 	lds	r18, 0x0712	; 0x800712 <__brkval>
    2254:	30 91 13 07 	lds	r19, 0x0713	; 0x800713 <__brkval+0x1>
    2258:	23 2b       	or	r18, r19
    225a:	41 f4       	brne	.+16     	; 0x226c <malloc+0xcc>
    225c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    2260:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    2264:	30 93 13 07 	sts	0x0713, r19	; 0x800713 <__brkval+0x1>
    2268:	20 93 12 07 	sts	0x0712, r18	; 0x800712 <__brkval>
    226c:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    2270:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    2274:	21 15       	cp	r18, r1
    2276:	31 05       	cpc	r19, r1
    2278:	41 f4       	brne	.+16     	; 0x228a <malloc+0xea>
    227a:	2d b7       	in	r18, 0x3d	; 61
    227c:	3e b7       	in	r19, 0x3e	; 62
    227e:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    2282:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    2286:	24 1b       	sub	r18, r20
    2288:	35 0b       	sbc	r19, r21
    228a:	e0 91 12 07 	lds	r30, 0x0712	; 0x800712 <__brkval>
    228e:	f0 91 13 07 	lds	r31, 0x0713	; 0x800713 <__brkval+0x1>
    2292:	e2 17       	cp	r30, r18
    2294:	f3 07       	cpc	r31, r19
    2296:	a0 f4       	brcc	.+40     	; 0x22c0 <malloc+0x120>
    2298:	2e 1b       	sub	r18, r30
    229a:	3f 0b       	sbc	r19, r31
    229c:	28 17       	cp	r18, r24
    229e:	39 07       	cpc	r19, r25
    22a0:	78 f0       	brcs	.+30     	; 0x22c0 <malloc+0x120>
    22a2:	ac 01       	movw	r20, r24
    22a4:	4e 5f       	subi	r20, 0xFE	; 254
    22a6:	5f 4f       	sbci	r21, 0xFF	; 255
    22a8:	24 17       	cp	r18, r20
    22aa:	35 07       	cpc	r19, r21
    22ac:	48 f0       	brcs	.+18     	; 0x22c0 <malloc+0x120>
    22ae:	4e 0f       	add	r20, r30
    22b0:	5f 1f       	adc	r21, r31
    22b2:	50 93 13 07 	sts	0x0713, r21	; 0x800713 <__brkval+0x1>
    22b6:	40 93 12 07 	sts	0x0712, r20	; 0x800712 <__brkval>
    22ba:	81 93       	st	Z+, r24
    22bc:	91 93       	st	Z+, r25
    22be:	02 c0       	rjmp	.+4      	; 0x22c4 <malloc+0x124>
    22c0:	e0 e0       	ldi	r30, 0x00	; 0
    22c2:	f0 e0       	ldi	r31, 0x00	; 0
    22c4:	cf 01       	movw	r24, r30
    22c6:	df 91       	pop	r29
    22c8:	cf 91       	pop	r28
    22ca:	1f 91       	pop	r17
    22cc:	0f 91       	pop	r16
    22ce:	08 95       	ret

000022d0 <free>:
    22d0:	cf 93       	push	r28
    22d2:	df 93       	push	r29
    22d4:	00 97       	sbiw	r24, 0x00	; 0
    22d6:	09 f4       	brne	.+2      	; 0x22da <free+0xa>
    22d8:	81 c0       	rjmp	.+258    	; 0x23dc <free+0x10c>
    22da:	fc 01       	movw	r30, r24
    22dc:	32 97       	sbiw	r30, 0x02	; 2
    22de:	13 82       	std	Z+3, r1	; 0x03
    22e0:	12 82       	std	Z+2, r1	; 0x02
    22e2:	a0 91 14 07 	lds	r26, 0x0714	; 0x800714 <__flp>
    22e6:	b0 91 15 07 	lds	r27, 0x0715	; 0x800715 <__flp+0x1>
    22ea:	10 97       	sbiw	r26, 0x00	; 0
    22ec:	81 f4       	brne	.+32     	; 0x230e <free+0x3e>
    22ee:	20 81       	ld	r18, Z
    22f0:	31 81       	ldd	r19, Z+1	; 0x01
    22f2:	82 0f       	add	r24, r18
    22f4:	93 1f       	adc	r25, r19
    22f6:	20 91 12 07 	lds	r18, 0x0712	; 0x800712 <__brkval>
    22fa:	30 91 13 07 	lds	r19, 0x0713	; 0x800713 <__brkval+0x1>
    22fe:	28 17       	cp	r18, r24
    2300:	39 07       	cpc	r19, r25
    2302:	51 f5       	brne	.+84     	; 0x2358 <free+0x88>
    2304:	f0 93 13 07 	sts	0x0713, r31	; 0x800713 <__brkval+0x1>
    2308:	e0 93 12 07 	sts	0x0712, r30	; 0x800712 <__brkval>
    230c:	67 c0       	rjmp	.+206    	; 0x23dc <free+0x10c>
    230e:	ed 01       	movw	r28, r26
    2310:	20 e0       	ldi	r18, 0x00	; 0
    2312:	30 e0       	ldi	r19, 0x00	; 0
    2314:	ce 17       	cp	r28, r30
    2316:	df 07       	cpc	r29, r31
    2318:	40 f4       	brcc	.+16     	; 0x232a <free+0x5a>
    231a:	4a 81       	ldd	r20, Y+2	; 0x02
    231c:	5b 81       	ldd	r21, Y+3	; 0x03
    231e:	9e 01       	movw	r18, r28
    2320:	41 15       	cp	r20, r1
    2322:	51 05       	cpc	r21, r1
    2324:	f1 f0       	breq	.+60     	; 0x2362 <free+0x92>
    2326:	ea 01       	movw	r28, r20
    2328:	f5 cf       	rjmp	.-22     	; 0x2314 <free+0x44>
    232a:	d3 83       	std	Z+3, r29	; 0x03
    232c:	c2 83       	std	Z+2, r28	; 0x02
    232e:	40 81       	ld	r20, Z
    2330:	51 81       	ldd	r21, Z+1	; 0x01
    2332:	84 0f       	add	r24, r20
    2334:	95 1f       	adc	r25, r21
    2336:	c8 17       	cp	r28, r24
    2338:	d9 07       	cpc	r29, r25
    233a:	59 f4       	brne	.+22     	; 0x2352 <free+0x82>
    233c:	88 81       	ld	r24, Y
    233e:	99 81       	ldd	r25, Y+1	; 0x01
    2340:	84 0f       	add	r24, r20
    2342:	95 1f       	adc	r25, r21
    2344:	02 96       	adiw	r24, 0x02	; 2
    2346:	91 83       	std	Z+1, r25	; 0x01
    2348:	80 83       	st	Z, r24
    234a:	8a 81       	ldd	r24, Y+2	; 0x02
    234c:	9b 81       	ldd	r25, Y+3	; 0x03
    234e:	93 83       	std	Z+3, r25	; 0x03
    2350:	82 83       	std	Z+2, r24	; 0x02
    2352:	21 15       	cp	r18, r1
    2354:	31 05       	cpc	r19, r1
    2356:	29 f4       	brne	.+10     	; 0x2362 <free+0x92>
    2358:	f0 93 15 07 	sts	0x0715, r31	; 0x800715 <__flp+0x1>
    235c:	e0 93 14 07 	sts	0x0714, r30	; 0x800714 <__flp>
    2360:	3d c0       	rjmp	.+122    	; 0x23dc <free+0x10c>
    2362:	e9 01       	movw	r28, r18
    2364:	fb 83       	std	Y+3, r31	; 0x03
    2366:	ea 83       	std	Y+2, r30	; 0x02
    2368:	49 91       	ld	r20, Y+
    236a:	59 91       	ld	r21, Y+
    236c:	c4 0f       	add	r28, r20
    236e:	d5 1f       	adc	r29, r21
    2370:	ec 17       	cp	r30, r28
    2372:	fd 07       	cpc	r31, r29
    2374:	61 f4       	brne	.+24     	; 0x238e <free+0xbe>
    2376:	80 81       	ld	r24, Z
    2378:	91 81       	ldd	r25, Z+1	; 0x01
    237a:	84 0f       	add	r24, r20
    237c:	95 1f       	adc	r25, r21
    237e:	02 96       	adiw	r24, 0x02	; 2
    2380:	e9 01       	movw	r28, r18
    2382:	99 83       	std	Y+1, r25	; 0x01
    2384:	88 83       	st	Y, r24
    2386:	82 81       	ldd	r24, Z+2	; 0x02
    2388:	93 81       	ldd	r25, Z+3	; 0x03
    238a:	9b 83       	std	Y+3, r25	; 0x03
    238c:	8a 83       	std	Y+2, r24	; 0x02
    238e:	e0 e0       	ldi	r30, 0x00	; 0
    2390:	f0 e0       	ldi	r31, 0x00	; 0
    2392:	12 96       	adiw	r26, 0x02	; 2
    2394:	8d 91       	ld	r24, X+
    2396:	9c 91       	ld	r25, X
    2398:	13 97       	sbiw	r26, 0x03	; 3
    239a:	00 97       	sbiw	r24, 0x00	; 0
    239c:	19 f0       	breq	.+6      	; 0x23a4 <free+0xd4>
    239e:	fd 01       	movw	r30, r26
    23a0:	dc 01       	movw	r26, r24
    23a2:	f7 cf       	rjmp	.-18     	; 0x2392 <free+0xc2>
    23a4:	8d 91       	ld	r24, X+
    23a6:	9c 91       	ld	r25, X
    23a8:	11 97       	sbiw	r26, 0x01	; 1
    23aa:	9d 01       	movw	r18, r26
    23ac:	2e 5f       	subi	r18, 0xFE	; 254
    23ae:	3f 4f       	sbci	r19, 0xFF	; 255
    23b0:	82 0f       	add	r24, r18
    23b2:	93 1f       	adc	r25, r19
    23b4:	20 91 12 07 	lds	r18, 0x0712	; 0x800712 <__brkval>
    23b8:	30 91 13 07 	lds	r19, 0x0713	; 0x800713 <__brkval+0x1>
    23bc:	28 17       	cp	r18, r24
    23be:	39 07       	cpc	r19, r25
    23c0:	69 f4       	brne	.+26     	; 0x23dc <free+0x10c>
    23c2:	30 97       	sbiw	r30, 0x00	; 0
    23c4:	29 f4       	brne	.+10     	; 0x23d0 <free+0x100>
    23c6:	10 92 15 07 	sts	0x0715, r1	; 0x800715 <__flp+0x1>
    23ca:	10 92 14 07 	sts	0x0714, r1	; 0x800714 <__flp>
    23ce:	02 c0       	rjmp	.+4      	; 0x23d4 <free+0x104>
    23d0:	13 82       	std	Z+3, r1	; 0x03
    23d2:	12 82       	std	Z+2, r1	; 0x02
    23d4:	b0 93 13 07 	sts	0x0713, r27	; 0x800713 <__brkval+0x1>
    23d8:	a0 93 12 07 	sts	0x0712, r26	; 0x800712 <__brkval>
    23dc:	df 91       	pop	r29
    23de:	cf 91       	pop	r28
    23e0:	08 95       	ret

000023e2 <memcpy>:
    23e2:	fb 01       	movw	r30, r22
    23e4:	dc 01       	movw	r26, r24
    23e6:	02 c0       	rjmp	.+4      	; 0x23ec <memcpy+0xa>
    23e8:	01 90       	ld	r0, Z+
    23ea:	0d 92       	st	X+, r0
    23ec:	41 50       	subi	r20, 0x01	; 1
    23ee:	50 40       	sbci	r21, 0x00	; 0
    23f0:	d8 f7       	brcc	.-10     	; 0x23e8 <memcpy+0x6>
    23f2:	08 95       	ret

000023f4 <memset>:
    23f4:	dc 01       	movw	r26, r24
    23f6:	01 c0       	rjmp	.+2      	; 0x23fa <memset+0x6>
    23f8:	6d 93       	st	X+, r22
    23fa:	41 50       	subi	r20, 0x01	; 1
    23fc:	50 40       	sbci	r21, 0x00	; 0
    23fe:	e0 f7       	brcc	.-8      	; 0x23f8 <memset+0x4>
    2400:	08 95       	ret

00002402 <_exit>:
    2402:	f8 94       	cli

00002404 <__stop_program>:
    2404:	ff cf       	rjmp	.-2      	; 0x2404 <__stop_program>
